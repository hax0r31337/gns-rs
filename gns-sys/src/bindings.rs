/* automatically generated by rust-bindgen 0.60.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STRING_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const _DYNAMIC_STACK_SIZE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_ISOCXX11: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_DYNAMIC_STACK_SIZE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 1;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 34;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 0;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 64;
pub const UINT_FAST16_WIDTH: u32 = 64;
pub const INT_FAST32_WIDTH: u32 = 64;
pub const UINT_FAST32_WIDTH: u32 = 64;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 64;
pub const UINTPTR_WIDTH: u32 = 64;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 64;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 64;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub const STEAMNETWORKINGSOCKETS_INTERFACE_VERSION: &[u8; 26usize] = b"SteamNetworkingSockets012\0";
pub const STEAMNETWORKINGUTILS_INTERFACE_VERSION: &[u8; 24usize] = b"SteamNetworkingUtils004\0";
pub type size_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rawmemchr(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memrchr(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    fn test_field___locales() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__locales)
            )
        );
    }
    test_field___locales();
    fn test_field___ctype_b() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_b)
            )
        );
    }
    test_field___ctype_b();
    fn test_field___ctype_tolower() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_tolower)
            )
        );
    }
    test_field___ctype_tolower();
    fn test_field___ctype_toupper() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_toupper)
            )
        );
    }
    test_field___ctype_toupper();
    fn test_field___names() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__names)
            )
        );
    }
    test_field___names();
}
impl Default for __locale_struct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *mut ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *mut ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchrnul(
        __s: *mut ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> size_t;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> size_t;
}
extern "C" {
    pub fn strpbrk(
        __s: *mut ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *mut ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasestr(
        __haystack: *mut ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: size_t,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> size_t;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerrordesc_np(__err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerrorname_np(__err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sigabbrev_np(__sig: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sigdescr_np(__sig: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strverscmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfry(__string: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memfrob(__s: *mut ::std::os::raw::c_void, __n: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn basename(__filename: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__fsid_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__fsid_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type uint8 = ::std::os::raw::c_uchar;
pub type int8 = ::std::os::raw::c_schar;
pub type int16 = ::std::os::raw::c_short;
pub type uint16 = ::std::os::raw::c_ushort;
pub type int32 = ::std::os::raw::c_int;
pub type uint32 = ::std::os::raw::c_uint;
pub type int64 = ::std::os::raw::c_longlong;
pub type uint64 = ::std::os::raw::c_ulonglong;
pub type lint64 = ::std::os::raw::c_long;
pub type ulint64 = ::std::os::raw::c_ulong;
pub type intp = ::std::os::raw::c_longlong;
pub type uintp = ::std::os::raw::c_ulonglong;
pub type AppId_t = uint32;
pub const k_uAppIdInvalid: AppId_t = 0;
pub type DepotId_t = uint32;
pub const k_uDepotIdInvalid: DepotId_t = 0;
pub type RTime32 = uint32;
pub type SteamAPICall_t = uint64;
pub const k_uAPICallInvalid: SteamAPICall_t = 0;
pub type AccountID_t = uint32;
pub type PartyBeaconID_t = uint64;
pub const k_ulPartyBeaconIdInvalid: PartyBeaconID_t = 0;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum ESteamIPType {
    k_ESteamIPTypeIPv4 = 0,
    k_ESteamIPTypeIPv6 = 1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SteamIPAddress_t {
    pub __bindgen_anon_1: SteamIPAddress_t__bindgen_ty_1,
    pub m_eType: ESteamIPType,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union SteamIPAddress_t__bindgen_ty_1 {
    pub m_unIPv4: uint32,
    pub m_rgubIPv6: [uint8; 16usize],
    pub m_ipv6Qword: [uint64; 2usize],
}
#[test]
fn bindgen_test_layout_SteamIPAddress_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SteamIPAddress_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(SteamIPAddress_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamIPAddress_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamIPAddress_t__bindgen_ty_1))
    );
    fn test_field_m_unIPv4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamIPAddress_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_unIPv4) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamIPAddress_t__bindgen_ty_1),
                "::",
                stringify!(m_unIPv4)
            )
        );
    }
    test_field_m_unIPv4();
    fn test_field_m_rgubIPv6() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamIPAddress_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_rgubIPv6) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamIPAddress_t__bindgen_ty_1),
                "::",
                stringify!(m_rgubIPv6)
            )
        );
    }
    test_field_m_rgubIPv6();
    fn test_field_m_ipv6Qword() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamIPAddress_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_ipv6Qword) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamIPAddress_t__bindgen_ty_1),
                "::",
                stringify!(m_ipv6Qword)
            )
        );
    }
    test_field_m_ipv6Qword();
}
impl Default for SteamIPAddress_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_SteamIPAddress_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamIPAddress_t>(),
        20usize,
        concat!("Size of: ", stringify!(SteamIPAddress_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamIPAddress_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamIPAddress_t))
    );
    fn test_field_m_eType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamIPAddress_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_eType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamIPAddress_t),
                "::",
                stringify!(m_eType)
            )
        );
    }
    test_field_m_eType();
}
impl Default for SteamIPAddress_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum EUniverse {
    k_EUniverseInvalid = 0,
    k_EUniversePublic = 1,
    k_EUniverseBeta = 2,
    k_EUniverseInternal = 3,
    k_EUniverseDev = 4,
    k_EUniverseMax = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum EResult {
    k_EResultNone = 0,
    k_EResultOK = 1,
    k_EResultFail = 2,
    k_EResultNoConnection = 3,
    k_EResultInvalidPassword = 5,
    k_EResultLoggedInElsewhere = 6,
    k_EResultInvalidProtocolVer = 7,
    k_EResultInvalidParam = 8,
    k_EResultFileNotFound = 9,
    k_EResultBusy = 10,
    k_EResultInvalidState = 11,
    k_EResultInvalidName = 12,
    k_EResultInvalidEmail = 13,
    k_EResultDuplicateName = 14,
    k_EResultAccessDenied = 15,
    k_EResultTimeout = 16,
    k_EResultBanned = 17,
    k_EResultAccountNotFound = 18,
    k_EResultInvalidSteamID = 19,
    k_EResultServiceUnavailable = 20,
    k_EResultNotLoggedOn = 21,
    k_EResultPending = 22,
    k_EResultEncryptionFailure = 23,
    k_EResultInsufficientPrivilege = 24,
    k_EResultLimitExceeded = 25,
    k_EResultRevoked = 26,
    k_EResultExpired = 27,
    k_EResultAlreadyRedeemed = 28,
    k_EResultDuplicateRequest = 29,
    k_EResultAlreadyOwned = 30,
    k_EResultIPNotFound = 31,
    k_EResultPersistFailed = 32,
    k_EResultLockingFailed = 33,
    k_EResultLogonSessionReplaced = 34,
    k_EResultConnectFailed = 35,
    k_EResultHandshakeFailed = 36,
    k_EResultIOFailure = 37,
    k_EResultRemoteDisconnect = 38,
    k_EResultShoppingCartNotFound = 39,
    k_EResultBlocked = 40,
    k_EResultIgnored = 41,
    k_EResultNoMatch = 42,
    k_EResultAccountDisabled = 43,
    k_EResultServiceReadOnly = 44,
    k_EResultAccountNotFeatured = 45,
    k_EResultAdministratorOK = 46,
    k_EResultContentVersion = 47,
    k_EResultTryAnotherCM = 48,
    k_EResultPasswordRequiredToKickSession = 49,
    k_EResultAlreadyLoggedInElsewhere = 50,
    k_EResultSuspended = 51,
    k_EResultCancelled = 52,
    k_EResultDataCorruption = 53,
    k_EResultDiskFull = 54,
    k_EResultRemoteCallFailed = 55,
    k_EResultPasswordUnset = 56,
    k_EResultExternalAccountUnlinked = 57,
    k_EResultPSNTicketInvalid = 58,
    k_EResultExternalAccountAlreadyLinked = 59,
    k_EResultRemoteFileConflict = 60,
    k_EResultIllegalPassword = 61,
    k_EResultSameAsPreviousValue = 62,
    k_EResultAccountLogonDenied = 63,
    k_EResultCannotUseOldPassword = 64,
    k_EResultInvalidLoginAuthCode = 65,
    k_EResultAccountLogonDeniedNoMail = 66,
    k_EResultHardwareNotCapableOfIPT = 67,
    k_EResultIPTInitError = 68,
    k_EResultParentalControlRestricted = 69,
    k_EResultFacebookQueryError = 70,
    k_EResultExpiredLoginAuthCode = 71,
    k_EResultIPLoginRestrictionFailed = 72,
    k_EResultAccountLockedDown = 73,
    k_EResultAccountLogonDeniedVerifiedEmailRequired = 74,
    k_EResultNoMatchingURL = 75,
    k_EResultBadResponse = 76,
    k_EResultRequirePasswordReEntry = 77,
    k_EResultValueOutOfRange = 78,
    k_EResultUnexpectedError = 79,
    k_EResultDisabled = 80,
    k_EResultInvalidCEGSubmission = 81,
    k_EResultRestrictedDevice = 82,
    k_EResultRegionLocked = 83,
    k_EResultRateLimitExceeded = 84,
    k_EResultAccountLoginDeniedNeedTwoFactor = 85,
    k_EResultItemDeleted = 86,
    k_EResultAccountLoginDeniedThrottle = 87,
    k_EResultTwoFactorCodeMismatch = 88,
    k_EResultTwoFactorActivationCodeMismatch = 89,
    k_EResultAccountAssociatedToMultiplePartners = 90,
    k_EResultNotModified = 91,
    k_EResultNoMobileDevice = 92,
    k_EResultTimeNotSynced = 93,
    k_EResultSmsCodeFailed = 94,
    k_EResultAccountLimitExceeded = 95,
    k_EResultAccountActivityLimitExceeded = 96,
    k_EResultPhoneActivityLimitExceeded = 97,
    k_EResultRefundToWallet = 98,
    k_EResultEmailSendFailure = 99,
    k_EResultNotSettled = 100,
    k_EResultNeedCaptcha = 101,
    k_EResultGSLTDenied = 102,
    k_EResultGSOwnerDenied = 103,
    k_EResultInvalidItemType = 104,
    k_EResultIPBanned = 105,
    k_EResultGSLTExpired = 106,
    k_EResultInsufficientFunds = 107,
    k_EResultTooManyPending = 108,
    k_EResultNoSiteLicensesFound = 109,
    k_EResultWGNetworkSendExceeded = 110,
    k_EResultAccountNotFriends = 111,
    k_EResultLimitedUserAccount = 112,
    k_EResultCantRemoveItem = 113,
    k_EResultAccountDeleted = 114,
    k_EResultExistingUserCancelledLicense = 115,
    k_EResultCommunityCooldown = 116,
    k_EResultNoLauncherSpecified = 117,
    k_EResultMustAgreeToSSA = 118,
    k_EResultLauncherMigrated = 119,
    k_EResultSteamRealmMismatch = 120,
    k_EResultInvalidSignature = 121,
    k_EResultParseFailure = 122,
    k_EResultNoVerifiedPhone = 123,
    k_EResultInsufficientBattery = 124,
    k_EResultChargerRequired = 125,
    k_EResultCachedCredentialInvalid = 126,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum EVoiceResult {
    k_EVoiceResultOK = 0,
    k_EVoiceResultNotInitialized = 1,
    k_EVoiceResultNotRecording = 2,
    k_EVoiceResultNoData = 3,
    k_EVoiceResultBufferTooSmall = 4,
    k_EVoiceResultDataCorrupted = 5,
    k_EVoiceResultRestricted = 6,
    k_EVoiceResultUnsupportedCodec = 7,
    k_EVoiceResultReceiverOutOfDate = 8,
    k_EVoiceResultReceiverDidNotAnswer = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum EDenyReason {
    k_EDenyInvalid = 0,
    k_EDenyInvalidVersion = 1,
    k_EDenyGeneric = 2,
    k_EDenyNotLoggedOn = 3,
    k_EDenyNoLicense = 4,
    k_EDenyCheater = 5,
    k_EDenyLoggedInElseWhere = 6,
    k_EDenyUnknownText = 7,
    k_EDenyIncompatibleAnticheat = 8,
    k_EDenyMemoryCorruption = 9,
    k_EDenyIncompatibleSoftware = 10,
    k_EDenySteamConnectionLost = 11,
    k_EDenySteamConnectionError = 12,
    k_EDenySteamResponseTimedOut = 13,
    k_EDenySteamValidationStalled = 14,
    k_EDenySteamOwnerLeftGuestUser = 15,
}
pub type HAuthTicket = uint32;
pub const k_HAuthTicketInvalid: HAuthTicket = 0;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum EBeginAuthSessionResult {
    k_EBeginAuthSessionResultOK = 0,
    k_EBeginAuthSessionResultInvalidTicket = 1,
    k_EBeginAuthSessionResultDuplicateRequest = 2,
    k_EBeginAuthSessionResultInvalidVersion = 3,
    k_EBeginAuthSessionResultGameMismatch = 4,
    k_EBeginAuthSessionResultExpiredTicket = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum EAuthSessionResponse {
    k_EAuthSessionResponseOK = 0,
    k_EAuthSessionResponseUserNotConnectedToSteam = 1,
    k_EAuthSessionResponseNoLicenseOrExpired = 2,
    k_EAuthSessionResponseVACBanned = 3,
    k_EAuthSessionResponseLoggedInElseWhere = 4,
    k_EAuthSessionResponseVACCheckTimedOut = 5,
    k_EAuthSessionResponseAuthTicketCanceled = 6,
    k_EAuthSessionResponseAuthTicketInvalidAlreadyUsed = 7,
    k_EAuthSessionResponseAuthTicketInvalid = 8,
    k_EAuthSessionResponsePublisherIssuedBan = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum EUserHasLicenseForAppResult {
    k_EUserHasLicenseResultHasLicense = 0,
    k_EUserHasLicenseResultDoesNotHaveLicense = 1,
    k_EUserHasLicenseResultNoAuth = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum EAccountType {
    k_EAccountTypeInvalid = 0,
    k_EAccountTypeIndividual = 1,
    k_EAccountTypeMultiseat = 2,
    k_EAccountTypeGameServer = 3,
    k_EAccountTypeAnonGameServer = 4,
    k_EAccountTypePending = 5,
    k_EAccountTypeContentServer = 6,
    k_EAccountTypeClan = 7,
    k_EAccountTypeChat = 8,
    k_EAccountTypeConsoleUser = 9,
    k_EAccountTypeAnonUser = 10,
    k_EAccountTypeMax = 11,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum EChatEntryType {
    k_EChatEntryTypeInvalid = 0,
    k_EChatEntryTypeChatMsg = 1,
    k_EChatEntryTypeTyping = 2,
    k_EChatEntryTypeInviteGame = 3,
    k_EChatEntryTypeEmote = 4,
    k_EChatEntryTypeLeftConversation = 6,
    k_EChatEntryTypeEntered = 7,
    k_EChatEntryTypeWasKicked = 8,
    k_EChatEntryTypeWasBanned = 9,
    k_EChatEntryTypeDisconnected = 10,
    k_EChatEntryTypeHistoricalChat = 11,
    k_EChatEntryTypeLinkBlocked = 14,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum EChatRoomEnterResponse {
    k_EChatRoomEnterResponseSuccess = 1,
    k_EChatRoomEnterResponseDoesntExist = 2,
    k_EChatRoomEnterResponseNotAllowed = 3,
    k_EChatRoomEnterResponseFull = 4,
    k_EChatRoomEnterResponseError = 5,
    k_EChatRoomEnterResponseBanned = 6,
    k_EChatRoomEnterResponseLimited = 7,
    k_EChatRoomEnterResponseClanDisabled = 8,
    k_EChatRoomEnterResponseCommunityBan = 9,
    k_EChatRoomEnterResponseMemberBlockedYou = 10,
    k_EChatRoomEnterResponseYouBlockedMember = 11,
    k_EChatRoomEnterResponseRatelimitExceeded = 15,
}
pub const k_unSteamAccountIDMask: ::std::os::raw::c_uint = 4294967295;
pub const k_unSteamAccountInstanceMask: ::std::os::raw::c_uint = 1048575;
pub const k_unSteamUserDefaultInstance: ::std::os::raw::c_uint = 1;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum EChatSteamIDInstanceFlags {
    k_EChatAccountInstanceMask = 4095,
    k_EChatInstanceFlagClan = 524288,
    k_EChatInstanceFlagLobby = 262144,
    k_EChatInstanceFlagMMSLobby = 131072,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum ENotificationPosition {
    k_EPositionTopLeft = 0,
    k_EPositionTopRight = 1,
    k_EPositionBottomLeft = 2,
    k_EPositionBottomRight = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum EBroadcastUploadResult {
    k_EBroadcastUploadResultNone = 0,
    k_EBroadcastUploadResultOK = 1,
    k_EBroadcastUploadResultInitFailed = 2,
    k_EBroadcastUploadResultFrameFailed = 3,
    k_EBroadcastUploadResultTimeout = 4,
    k_EBroadcastUploadResultBandwidthExceeded = 5,
    k_EBroadcastUploadResultLowFPS = 6,
    k_EBroadcastUploadResultMissingKeyFrames = 7,
    k_EBroadcastUploadResultNoConnection = 8,
    k_EBroadcastUploadResultRelayFailed = 9,
    k_EBroadcastUploadResultSettingsChanged = 10,
    k_EBroadcastUploadResultMissingAudio = 11,
    k_EBroadcastUploadResultTooFarBehind = 12,
    k_EBroadcastUploadResultTranscodeBehind = 13,
    k_EBroadcastUploadResultNotAllowedToPlay = 14,
    k_EBroadcastUploadResultBusy = 15,
    k_EBroadcastUploadResultBanned = 16,
    k_EBroadcastUploadResultAlreadyActive = 17,
    k_EBroadcastUploadResultForcedOff = 18,
    k_EBroadcastUploadResultAudioBehind = 19,
    k_EBroadcastUploadResultShutdown = 20,
    k_EBroadcastUploadResultDisconnect = 21,
    k_EBroadcastUploadResultVideoInitFailed = 22,
    k_EBroadcastUploadResultAudioInitFailed = 23,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum EMarketNotAllowedReasonFlags {
    k_EMarketNotAllowedReason_None = 0,
    k_EMarketNotAllowedReason_TemporaryFailure = 1,
    k_EMarketNotAllowedReason_AccountDisabled = 2,
    k_EMarketNotAllowedReason_AccountLockedDown = 4,
    k_EMarketNotAllowedReason_AccountLimited = 8,
    k_EMarketNotAllowedReason_TradeBanned = 16,
    k_EMarketNotAllowedReason_AccountNotTrusted = 32,
    k_EMarketNotAllowedReason_SteamGuardNotEnabled = 64,
    k_EMarketNotAllowedReason_SteamGuardOnlyRecentlyEnabled = 128,
    k_EMarketNotAllowedReason_RecentPasswordReset = 256,
    k_EMarketNotAllowedReason_NewPaymentMethod = 512,
    k_EMarketNotAllowedReason_InvalidCookie = 1024,
    k_EMarketNotAllowedReason_UsingNewDevice = 2048,
    k_EMarketNotAllowedReason_RecentSelfRefund = 4096,
    k_EMarketNotAllowedReason_NewPaymentMethodCannotBeVerified = 8192,
    k_EMarketNotAllowedReason_NoRecentPurchases = 16384,
    k_EMarketNotAllowedReason_AcceptedWalletGift = 32768,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum EDurationControlProgress {
    k_EDurationControlProgress_Full = 0,
    k_EDurationControlProgress_Half = 1,
    k_EDurationControlProgress_None = 2,
    k_EDurationControl_ExitSoon_3h = 3,
    k_EDurationControl_ExitSoon_5h = 4,
    k_EDurationControl_ExitSoon_Night = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum EDurationControlNotification {
    k_EDurationControlNotification_None = 0,
    k_EDurationControlNotification_1Hour = 1,
    k_EDurationControlNotification_3Hours = 2,
    k_EDurationControlNotification_HalfProgress = 3,
    k_EDurationControlNotification_NoProgress = 4,
    k_EDurationControlNotification_ExitSoon_3h = 5,
    k_EDurationControlNotification_ExitSoon_5h = 6,
    k_EDurationControlNotification_ExitSoon_Night = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum EDurationControlOnlineState {
    k_EDurationControlOnlineState_Invalid = 0,
    k_EDurationControlOnlineState_Offline = 1,
    k_EDurationControlOnlineState_Online = 2,
    k_EDurationControlOnlineState_OnlineHighPri = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CSteamID {
    pub m_steamid: CSteamID_SteamID_t,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union CSteamID_SteamID_t {
    pub m_comp: CSteamID_SteamID_t_SteamIDComponent_t,
    pub m_unAll64Bits: uint64,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CSteamID_SteamID_t_SteamIDComponent_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_CSteamID_SteamID_t_SteamIDComponent_t() {
    assert_eq!(
        ::std::mem::size_of::<CSteamID_SteamID_t_SteamIDComponent_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CSteamID_SteamID_t_SteamIDComponent_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CSteamID_SteamID_t_SteamIDComponent_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(CSteamID_SteamID_t_SteamIDComponent_t)
        )
    );
}
impl Default for CSteamID_SteamID_t_SteamIDComponent_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl CSteamID_SteamID_t_SteamIDComponent_t {
    #[inline]
    pub fn m_unAccountID(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_m_unAccountID(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn m_unAccountInstance(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_m_unAccountInstance(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn m_EAccountType(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_m_EAccountType(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn m_EUniverse(&self) -> EUniverse {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_m_EUniverse(&mut self, val: EUniverse) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        m_unAccountID: uint32,
        m_unAccountInstance: ::std::os::raw::c_uint,
        m_EAccountType: ::std::os::raw::c_uint,
        m_EUniverse: EUniverse,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let m_unAccountID: u32 = unsafe { ::std::mem::transmute(m_unAccountID) };
            m_unAccountID as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let m_unAccountInstance: u32 = unsafe { ::std::mem::transmute(m_unAccountInstance) };
            m_unAccountInstance as u64
        });
        __bindgen_bitfield_unit.set(52usize, 4u8, {
            let m_EAccountType: u32 = unsafe { ::std::mem::transmute(m_EAccountType) };
            m_EAccountType as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let m_EUniverse: u32 = unsafe { ::std::mem::transmute(m_EUniverse) };
            m_EUniverse as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_CSteamID_SteamID_t() {
    assert_eq!(
        ::std::mem::size_of::<CSteamID_SteamID_t>(),
        8usize,
        concat!("Size of: ", stringify!(CSteamID_SteamID_t))
    );
    assert_eq!(
        ::std::mem::align_of::<CSteamID_SteamID_t>(),
        1usize,
        concat!("Alignment of ", stringify!(CSteamID_SteamID_t))
    );
    fn test_field_m_comp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CSteamID_SteamID_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_comp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CSteamID_SteamID_t),
                "::",
                stringify!(m_comp)
            )
        );
    }
    test_field_m_comp();
    fn test_field_m_unAll64Bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CSteamID_SteamID_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_unAll64Bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CSteamID_SteamID_t),
                "::",
                stringify!(m_unAll64Bits)
            )
        );
    }
    test_field_m_unAll64Bits();
}
impl Default for CSteamID_SteamID_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_CSteamID() {
    assert_eq!(
        ::std::mem::size_of::<CSteamID>(),
        8usize,
        concat!("Size of: ", stringify!(CSteamID))
    );
    assert_eq!(
        ::std::mem::align_of::<CSteamID>(),
        1usize,
        concat!("Alignment of ", stringify!(CSteamID))
    );
    fn test_field_m_steamid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CSteamID>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_steamid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CSteamID),
                "::",
                stringify!(m_steamid)
            )
        );
    }
    test_field_m_steamid();
}
extern "C" {
    #[link_name = "\u{1}_ZNK8CSteamID7IsValidEv"]
    pub fn CSteamID_IsValid(this: *const CSteamID) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8CSteamID6RenderEv"]
    pub fn CSteamID_Render(this: *const CSteamID) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN8CSteamID6RenderEy"]
    pub fn CSteamID_Render1(ulSteamID: uint64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN8CSteamID13SetFromStringEPKc9EUniverse"]
    pub fn CSteamID_SetFromString(
        this: *mut CSteamID,
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8CSteamID19SetFromStringStrictEPKc9EUniverse"]
    pub fn CSteamID_SetFromStringStrict(
        this: *mut CSteamID,
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8CSteamID21BValidExternalSteamIDEv"]
    pub fn CSteamID_BValidExternalSteamID(this: *const CSteamID) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8CSteamIDC1EPKc9EUniverse"]
    pub fn CSteamID_CSteamID(
        this: *mut CSteamID,
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    );
}
impl Default for CSteamID {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl CSteamID {
    #[inline]
    pub unsafe fn IsValid(&self) -> bool {
        CSteamID_IsValid(self)
    }
    #[inline]
    pub unsafe fn Render(&self) -> *const ::std::os::raw::c_char {
        CSteamID_Render(self)
    }
    #[inline]
    pub unsafe fn Render1(ulSteamID: uint64) -> *const ::std::os::raw::c_char {
        CSteamID_Render1(ulSteamID)
    }
    #[inline]
    pub unsafe fn SetFromString(
        &mut self,
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    ) {
        CSteamID_SetFromString(self, pchSteamID, eDefaultUniverse)
    }
    #[inline]
    pub unsafe fn SetFromStringStrict(
        &mut self,
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    ) -> bool {
        CSteamID_SetFromStringStrict(self, pchSteamID, eDefaultUniverse)
    }
    #[inline]
    pub unsafe fn BValidExternalSteamID(&self) -> bool {
        CSteamID_BValidExternalSteamID(self)
    }
    #[inline]
    pub unsafe fn new(
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        CSteamID_CSteamID(__bindgen_tmp.as_mut_ptr(), pchSteamID, eDefaultUniverse);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CGameID {
    pub __bindgen_anon_1: CGameID__bindgen_ty_1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CGameID_EGameIDType {
    k_EGameIDTypeApp = 0,
    k_EGameIDTypeGameMod = 1,
    k_EGameIDTypeShortcut = 2,
    k_EGameIDTypeP2P = 3,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CGameID_GameID_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_CGameID_GameID_t() {
    assert_eq!(
        ::std::mem::size_of::<CGameID_GameID_t>(),
        8usize,
        concat!("Size of: ", stringify!(CGameID_GameID_t))
    );
    assert_eq!(
        ::std::mem::align_of::<CGameID_GameID_t>(),
        1usize,
        concat!("Alignment of ", stringify!(CGameID_GameID_t))
    );
}
impl CGameID_GameID_t {
    #[inline]
    pub fn m_nAppID(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_m_nAppID(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn m_nType(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_m_nType(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn m_nModID(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_m_nModID(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        m_nAppID: ::std::os::raw::c_uint,
        m_nType: ::std::os::raw::c_uint,
        m_nModID: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let m_nAppID: u32 = unsafe { ::std::mem::transmute(m_nAppID) };
            m_nAppID as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let m_nType: u32 = unsafe { ::std::mem::transmute(m_nType) };
            m_nType as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let m_nModID: u32 = unsafe { ::std::mem::transmute(m_nModID) };
            m_nModID as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union CGameID__bindgen_ty_1 {
    pub m_ulGameID: uint64,
    pub m_gameID: CGameID_GameID_t,
}
#[test]
fn bindgen_test_layout_CGameID__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CGameID__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(CGameID__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CGameID__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(CGameID__bindgen_ty_1))
    );
    fn test_field_m_ulGameID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CGameID__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_ulGameID) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CGameID__bindgen_ty_1),
                "::",
                stringify!(m_ulGameID)
            )
        );
    }
    test_field_m_ulGameID();
    fn test_field_m_gameID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CGameID__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_gameID) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CGameID__bindgen_ty_1),
                "::",
                stringify!(m_gameID)
            )
        );
    }
    test_field_m_gameID();
}
impl Default for CGameID__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_CGameID() {
    assert_eq!(
        ::std::mem::size_of::<CGameID>(),
        8usize,
        concat!("Size of: ", stringify!(CGameID))
    );
    assert_eq!(
        ::std::mem::align_of::<CGameID>(),
        1usize,
        concat!("Alignment of ", stringify!(CGameID))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK7CGameID6RenderEv"]
    pub fn CGameID_Render(this: *const CGameID) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN7CGameID6RenderEy"]
    pub fn CGameID_Render1(ulGameID: uint64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN7CGameIDC1EPKc"]
    pub fn CGameID_CGameID(this: *mut CGameID, pchGameID: *const ::std::os::raw::c_char);
}
impl Default for CGameID {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl CGameID {
    #[inline]
    pub unsafe fn Render(&self) -> *const ::std::os::raw::c_char {
        CGameID_Render(self)
    }
    #[inline]
    pub unsafe fn Render1(ulGameID: uint64) -> *const ::std::os::raw::c_char {
        CGameID_Render1(ulGameID)
    }
    #[inline]
    pub unsafe fn new(pchGameID: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        CGameID_CGameID(__bindgen_tmp.as_mut_ptr(), pchGameID);
        __bindgen_tmp.assume_init()
    }
}
pub const k_cchGameExtraInfoMax: ::std::os::raw::c_int = 64;
pub type PFNPreMinidumpCallback =
    ::std::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void)>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum EGameSearchErrorCode_t {
    k_EGameSearchErrorCode_OK = 1,
    k_EGameSearchErrorCode_Failed_Search_Already_In_Progress = 2,
    k_EGameSearchErrorCode_Failed_No_Search_In_Progress = 3,
    k_EGameSearchErrorCode_Failed_Not_Lobby_Leader = 4,
    k_EGameSearchErrorCode_Failed_No_Host_Available = 5,
    k_EGameSearchErrorCode_Failed_Search_Params_Invalid = 6,
    k_EGameSearchErrorCode_Failed_Offline = 7,
    k_EGameSearchErrorCode_Failed_NotAuthorized = 8,
    k_EGameSearchErrorCode_Failed_Unknown_Error = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum EPlayerResult_t {
    k_EPlayerResultFailedToConnect = 1,
    k_EPlayerResultAbandoned = 2,
    k_EPlayerResultKicked = 3,
    k_EPlayerResultIncomplete = 4,
    k_EPlayerResultCompleted = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum ESteamIPv6ConnectivityProtocol {
    k_ESteamIPv6ConnectivityProtocol_Invalid = 0,
    k_ESteamIPv6ConnectivityProtocol_HTTP = 1,
    k_ESteamIPv6ConnectivityProtocol_UDP = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum ESteamIPv6ConnectivityState {
    k_ESteamIPv6ConnectivityState_Unknown = 0,
    k_ESteamIPv6ConnectivityState_Good = 1,
    k_ESteamIPv6ConnectivityState_Bad = 2,
}
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct ValvePackingSentinel_t {
    pub m_u32: uint32,
    pub m_u64: uint64,
    pub m_u16: uint16,
    pub m_d: f64,
}
#[test]
fn bindgen_test_layout_ValvePackingSentinel_t() {
    assert_eq!(
        ::std::mem::size_of::<ValvePackingSentinel_t>(),
        24usize,
        concat!("Size of: ", stringify!(ValvePackingSentinel_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ValvePackingSentinel_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ValvePackingSentinel_t))
    );
    fn test_field_m_u32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ValvePackingSentinel_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_u32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ValvePackingSentinel_t),
                "::",
                stringify!(m_u32)
            )
        );
    }
    test_field_m_u32();
    fn test_field_m_u64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ValvePackingSentinel_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_u64) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ValvePackingSentinel_t),
                "::",
                stringify!(m_u64)
            )
        );
    }
    test_field_m_u64();
    fn test_field_m_u16() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ValvePackingSentinel_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_u16) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(ValvePackingSentinel_t),
                "::",
                stringify!(m_u16)
            )
        );
    }
    test_field_m_u16();
    fn test_field_m_d() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ValvePackingSentinel_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_d) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ValvePackingSentinel_t),
                "::",
                stringify!(m_d)
            )
        );
    }
    test_field_m_d();
}
pub type compile_time_assert_type = [::std::os::raw::c_char; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamDatagramRelayAuthTicket {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamDatagramHostedAddress {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamDatagramGameCoordinatorServerLogin {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkingMessagesSessionRequest_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkingMessagesSessionFailed_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkingFakeIPResult_t {
    _unused: [u8; 0],
}
pub type FnSteamNetConnectionStatusChanged = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut SteamNetConnectionStatusChangedCallback_t),
>;
pub type FnSteamNetAuthenticationStatusChanged =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamNetAuthenticationStatus_t)>;
pub type FnSteamRelayNetworkStatusChanged =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamRelayNetworkStatus_t)>;
pub type FnSteamNetworkingMessagesSessionRequest =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamNetworkingMessagesSessionRequest_t)>;
pub type FnSteamNetworkingMessagesSessionFailed =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamNetworkingMessagesSessionFailed_t)>;
pub type FnSteamNetworkingFakeIPResult =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamNetworkingFakeIPResult_t)>;
#[doc = " Handle used to identify a connection to a remote host."]
pub type HSteamNetConnection = uint32;
pub const k_HSteamNetConnection_Invalid: HSteamNetConnection = 0;
#[doc = " Handle used to identify a \"listen socket\".  Unlike traditional"]
#[doc = " Berkeley sockets, a listen socket and a connection are two"]
#[doc = " different abstractions."]
pub type HSteamListenSocket = uint32;
pub const k_HSteamListenSocket_Invalid: HSteamListenSocket = 0;
#[doc = " Handle used to identify a poll group, used to query many"]
#[doc = " connections at once efficiently."]
pub type HSteamNetPollGroup = uint32;
pub const k_HSteamNetPollGroup_Invalid: HSteamNetPollGroup = 0;
#[doc = " Max length of diagnostic error message"]
pub const k_cchMaxSteamNetworkingErrMsg: ::std::os::raw::c_int = 1024;
#[doc = " Used to return English-language diagnostic error messages to caller."]
#[doc = " (For debugging or spewing to a console, etc.  Not intended for UI.)"]
pub type SteamNetworkingErrMsg = [::std::os::raw::c_char; 1024usize];
#[doc = " Identifier used for a network location point of presence.  (E.g. a Valve data center.)"]
#[doc = " Typically you won't need to directly manipulate these."]
pub type SteamNetworkingPOPID = uint32;
#[doc = " A local timestamp.  You can subtract two timestamps to get the number of elapsed"]
#[doc = " microseconds.  This is guaranteed to increase over time during the lifetime"]
#[doc = " of a process, but not globally across runs.  You don't need to worry about"]
#[doc = " the value wrapping around.  Note that the underlying clock might not actually have"]
#[doc = " microsecond resolution."]
pub type SteamNetworkingMicroseconds = int64;
#[repr(i32)]
#[doc = " Describe the status of a particular network resource"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum ESteamNetworkingAvailability {
    k_ESteamNetworkingAvailability_CannotTry = -102,
    k_ESteamNetworkingAvailability_Failed = -101,
    k_ESteamNetworkingAvailability_Previously = -100,
    k_ESteamNetworkingAvailability_Retrying = -10,
    k_ESteamNetworkingAvailability_NeverTried = 1,
    k_ESteamNetworkingAvailability_Waiting = 2,
    k_ESteamNetworkingAvailability_Attempting = 3,
    k_ESteamNetworkingAvailability_Current = 100,
    k_ESteamNetworkingAvailability_Unknown = 0,
    k_ESteamNetworkingAvailability__Force32bit = 2147483647,
}
#[repr(u32)]
#[doc = " Different methods of describing the identity of a network host"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum ESteamNetworkingIdentityType {
    k_ESteamNetworkingIdentityType_Invalid = 0,
    k_ESteamNetworkingIdentityType_SteamID = 16,
    k_ESteamNetworkingIdentityType_IPAddress = 1,
    k_ESteamNetworkingIdentityType_GenericString = 2,
    k_ESteamNetworkingIdentityType_GenericBytes = 3,
    k_ESteamNetworkingIdentityType_UnknownType = 4,
    k_ESteamNetworkingIdentityType__Force32bit = 2147483647,
}
#[repr(u32)]
#[doc = " \"Fake IPs\" are assigned to hosts, to make it easier to interface with"]
#[doc = " older code that assumed all hosts will have an IPv4 address"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum ESteamNetworkingFakeIPType {
    k_ESteamNetworkingFakeIPType_Invalid = 0,
    k_ESteamNetworkingFakeIPType_NotFake = 1,
    k_ESteamNetworkingFakeIPType_GlobalIPv4 = 2,
    k_ESteamNetworkingFakeIPType_LocalIPv4 = 3,
    k_ESteamNetworkingFakeIPType__Force32Bit = 2147483647,
}
#[doc = " Store an IP and port.  IPv6 is always used; IPv4 is represented using"]
#[doc = " \"IPv4-mapped\" addresses: IPv4 aa.bb.cc.dd => IPv6 ::ffff:aabb:ccdd"]
#[doc = " (RFC 4291 section 2.5.5.2.)"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SteamNetworkingIPAddr {
    pub __bindgen_anon_1: SteamNetworkingIPAddr__bindgen_ty_2,
    pub m_port: uint16,
}
pub const SteamNetworkingIPAddr_k_cchMaxString: SteamNetworkingIPAddr__bindgen_ty_1 =
    SteamNetworkingIPAddr__bindgen_ty_1::k_cchMaxString;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum SteamNetworkingIPAddr__bindgen_ty_1 {
    k_cchMaxString = 48,
}
#[doc = " RFC4038, section 4.2"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct SteamNetworkingIPAddr_IPv4MappedAddress {
    pub m_8zeros: uint64,
    pub m_0000: uint16,
    pub m_ffff: uint16,
    pub m_ip: [uint8; 4usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkingIPAddr_IPv4MappedAddress() {
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIPAddr_IPv4MappedAddress>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetworkingIPAddr_IPv4MappedAddress)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIPAddr_IPv4MappedAddress>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingIPAddr_IPv4MappedAddress)
        )
    );
    fn test_field_m_8zeros() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetworkingIPAddr_IPv4MappedAddress>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_8zeros) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingIPAddr_IPv4MappedAddress),
                "::",
                stringify!(m_8zeros)
            )
        );
    }
    test_field_m_8zeros();
    fn test_field_m_0000() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetworkingIPAddr_IPv4MappedAddress>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_0000) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingIPAddr_IPv4MappedAddress),
                "::",
                stringify!(m_0000)
            )
        );
    }
    test_field_m_0000();
    fn test_field_m_ffff() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetworkingIPAddr_IPv4MappedAddress>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_ffff) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingIPAddr_IPv4MappedAddress),
                "::",
                stringify!(m_ffff)
            )
        );
    }
    test_field_m_ffff();
    fn test_field_m_ip() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetworkingIPAddr_IPv4MappedAddress>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_ip) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingIPAddr_IPv4MappedAddress),
                "::",
                stringify!(m_ip)
            )
        );
    }
    test_field_m_ip();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SteamNetworkingIPAddr__bindgen_ty_2 {
    pub m_ipv6: [uint8; 16usize],
    pub m_ipv4: SteamNetworkingIPAddr_IPv4MappedAddress,
}
#[test]
fn bindgen_test_layout_SteamNetworkingIPAddr__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIPAddr__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(SteamNetworkingIPAddr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIPAddr__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingIPAddr__bindgen_ty_2)
        )
    );
    fn test_field_m_ipv6() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetworkingIPAddr__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_ipv6) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingIPAddr__bindgen_ty_2),
                "::",
                stringify!(m_ipv6)
            )
        );
    }
    test_field_m_ipv6();
    fn test_field_m_ipv4() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetworkingIPAddr__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_ipv4) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingIPAddr__bindgen_ty_2),
                "::",
                stringify!(m_ipv4)
            )
        );
    }
    test_field_m_ipv4();
}
impl Default for SteamNetworkingIPAddr__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_SteamNetworkingIPAddr() {
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIPAddr>(),
        18usize,
        concat!("Size of: ", stringify!(SteamNetworkingIPAddr))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIPAddr>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkingIPAddr))
    );
    fn test_field_m_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingIPAddr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_port) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingIPAddr),
                "::",
                stringify!(m_port)
            )
        );
    }
    test_field_m_port();
}
extern "C" {
    #[link_name = "\u{1}_ZN21SteamNetworkingIPAddr5ClearEv"]
    pub fn SteamNetworkingIPAddr_Clear(this: *mut SteamNetworkingIPAddr);
}
extern "C" {
    #[link_name = "\u{1}_ZNK21SteamNetworkingIPAddr14IsIPv6AllZerosEv"]
    pub fn SteamNetworkingIPAddr_IsIPv6AllZeros(this: *const SteamNetworkingIPAddr) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN21SteamNetworkingIPAddr7SetIPv6EPKht"]
    pub fn SteamNetworkingIPAddr_SetIPv6(
        this: *mut SteamNetworkingIPAddr,
        ipv6: *const uint8,
        nPort: uint16,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21SteamNetworkingIPAddr7SetIPv4Ejt"]
    pub fn SteamNetworkingIPAddr_SetIPv4(
        this: *mut SteamNetworkingIPAddr,
        nIP: uint32,
        nPort: uint16,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21SteamNetworkingIPAddr6IsIPv4Ev"]
    pub fn SteamNetworkingIPAddr_IsIPv4(this: *const SteamNetworkingIPAddr) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21SteamNetworkingIPAddr7GetIPv4Ev"]
    pub fn SteamNetworkingIPAddr_GetIPv4(this: *const SteamNetworkingIPAddr) -> uint32;
}
extern "C" {
    #[link_name = "\u{1}_ZN21SteamNetworkingIPAddr16SetIPv6LocalHostEt"]
    pub fn SteamNetworkingIPAddr_SetIPv6LocalHost(this: *mut SteamNetworkingIPAddr, nPort: uint16);
}
extern "C" {
    #[link_name = "\u{1}_ZNK21SteamNetworkingIPAddr11IsLocalHostEv"]
    pub fn SteamNetworkingIPAddr_IsLocalHost(this: *const SteamNetworkingIPAddr) -> bool;
}
extern "C" {
    #[doc = " Classify address as FakeIP.  This function never returns"]
    #[doc = " k_ESteamNetworkingFakeIPType_Invalid."]
    #[link_name = "\u{1}_ZNK21SteamNetworkingIPAddr13GetFakeIPTypeEv"]
    pub fn SteamNetworkingIPAddr_GetFakeIPType(
        this: *const SteamNetworkingIPAddr,
    ) -> ESteamNetworkingFakeIPType;
}
impl Default for SteamNetworkingIPAddr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl SteamNetworkingIPAddr {
    #[inline]
    pub unsafe fn Clear(&mut self) {
        SteamNetworkingIPAddr_Clear(self)
    }
    #[inline]
    pub unsafe fn IsIPv6AllZeros(&self) -> bool {
        SteamNetworkingIPAddr_IsIPv6AllZeros(self)
    }
    #[inline]
    pub unsafe fn SetIPv6(&mut self, ipv6: *const uint8, nPort: uint16) {
        SteamNetworkingIPAddr_SetIPv6(self, ipv6, nPort)
    }
    #[inline]
    pub unsafe fn SetIPv4(&mut self, nIP: uint32, nPort: uint16) {
        SteamNetworkingIPAddr_SetIPv4(self, nIP, nPort)
    }
    #[inline]
    pub unsafe fn IsIPv4(&self) -> bool {
        SteamNetworkingIPAddr_IsIPv4(self)
    }
    #[inline]
    pub unsafe fn GetIPv4(&self) -> uint32 {
        SteamNetworkingIPAddr_GetIPv4(self)
    }
    #[inline]
    pub unsafe fn SetIPv6LocalHost(&mut self, nPort: uint16) {
        SteamNetworkingIPAddr_SetIPv6LocalHost(self, nPort)
    }
    #[inline]
    pub unsafe fn IsLocalHost(&self) -> bool {
        SteamNetworkingIPAddr_IsLocalHost(self)
    }
    #[inline]
    pub unsafe fn GetFakeIPType(&self) -> ESteamNetworkingFakeIPType {
        SteamNetworkingIPAddr_GetFakeIPType(self)
    }
}
#[doc = " An abstract way to represent the identity of a network host.  All identities can"]
#[doc = " be represented as simple string.  Furthermore, this string representation is actually"]
#[doc = " used on the wire in several places, even though it is less efficient, in order to"]
#[doc = " facilitate forward compatibility.  (Old client code can handle an identity type that"]
#[doc = " it doesn't understand.)"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SteamNetworkingIdentity {
    #[doc = " Type of identity."]
    pub m_eType: ESteamNetworkingIdentityType,
    pub m_cbSize: ::std::os::raw::c_int,
    pub __bindgen_anon_1: SteamNetworkingIdentity__bindgen_ty_2,
}
pub const SteamNetworkingIdentity_k_cchMaxString: SteamNetworkingIdentity__bindgen_ty_1 =
    SteamNetworkingIdentity__bindgen_ty_1::k_cchMaxString;
pub const SteamNetworkingIdentity_k_cchMaxGenericString: SteamNetworkingIdentity__bindgen_ty_1 =
    SteamNetworkingIdentity__bindgen_ty_1::k_cchMaxGenericString;
pub const SteamNetworkingIdentity_k_cbMaxGenericBytes: SteamNetworkingIdentity__bindgen_ty_1 =
    SteamNetworkingIdentity__bindgen_ty_1::k_cchMaxGenericString;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum SteamNetworkingIdentity__bindgen_ty_1 {
    k_cchMaxString = 128,
    k_cchMaxGenericString = 32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union SteamNetworkingIdentity__bindgen_ty_2 {
    pub m_steamID64: uint64,
    pub m_szGenericString: [::std::os::raw::c_char; 32usize],
    pub m_genericBytes: [uint8; 32usize],
    pub m_szUnknownRawString: [::std::os::raw::c_char; 128usize],
    pub m_ip: SteamNetworkingIPAddr,
    pub m_reserved: [uint32; 32usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkingIdentity__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIdentity__bindgen_ty_2>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIdentity__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2)
        )
    );
    fn test_field_m_steamID64() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetworkingIdentity__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_steamID64) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingIdentity__bindgen_ty_2),
                "::",
                stringify!(m_steamID64)
            )
        );
    }
    test_field_m_steamID64();
    fn test_field_m_szGenericString() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetworkingIdentity__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_szGenericString) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingIdentity__bindgen_ty_2),
                "::",
                stringify!(m_szGenericString)
            )
        );
    }
    test_field_m_szGenericString();
    fn test_field_m_genericBytes() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetworkingIdentity__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_genericBytes) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingIdentity__bindgen_ty_2),
                "::",
                stringify!(m_genericBytes)
            )
        );
    }
    test_field_m_genericBytes();
    fn test_field_m_szUnknownRawString() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetworkingIdentity__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_szUnknownRawString) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingIdentity__bindgen_ty_2),
                "::",
                stringify!(m_szUnknownRawString)
            )
        );
    }
    test_field_m_szUnknownRawString();
    fn test_field_m_ip() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetworkingIdentity__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_ip) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingIdentity__bindgen_ty_2),
                "::",
                stringify!(m_ip)
            )
        );
    }
    test_field_m_ip();
    fn test_field_m_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetworkingIdentity__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingIdentity__bindgen_ty_2),
                "::",
                stringify!(m_reserved)
            )
        );
    }
    test_field_m_reserved();
}
impl Default for SteamNetworkingIdentity__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_SteamNetworkingIdentity() {
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIdentity>(),
        136usize,
        concat!("Size of: ", stringify!(SteamNetworkingIdentity))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIdentity>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkingIdentity))
    );
    fn test_field_m_eType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingIdentity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_eType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingIdentity),
                "::",
                stringify!(m_eType)
            )
        );
    }
    test_field_m_eType();
    fn test_field_m_cbSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingIdentity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_cbSize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingIdentity),
                "::",
                stringify!(m_cbSize)
            )
        );
    }
    test_field_m_cbSize();
}
extern "C" {
    #[link_name = "\u{1}_ZN23SteamNetworkingIdentity5ClearEv"]
    pub fn SteamNetworkingIdentity_Clear(this: *mut SteamNetworkingIdentity);
}
extern "C" {
    #[link_name = "\u{1}_ZNK23SteamNetworkingIdentity9IsInvalidEv"]
    pub fn SteamNetworkingIdentity_IsInvalid(this: *const SteamNetworkingIdentity) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN23SteamNetworkingIdentity10SetSteamIDE8CSteamID"]
    pub fn SteamNetworkingIdentity_SetSteamID(
        this: *mut SteamNetworkingIdentity,
        steamID: CSteamID,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23SteamNetworkingIdentity10GetSteamIDEv"]
    pub fn SteamNetworkingIdentity_GetSteamID(this: *const SteamNetworkingIdentity) -> CSteamID;
}
extern "C" {
    #[link_name = "\u{1}_ZN23SteamNetworkingIdentity12SetSteamID64Ey"]
    pub fn SteamNetworkingIdentity_SetSteamID64(
        this: *mut SteamNetworkingIdentity,
        steamID: uint64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23SteamNetworkingIdentity12GetSteamID64Ev"]
    pub fn SteamNetworkingIdentity_GetSteamID64(this: *const SteamNetworkingIdentity) -> uint64;
}
extern "C" {
    #[link_name = "\u{1}_ZN23SteamNetworkingIdentity9SetIPAddrERK21SteamNetworkingIPAddr"]
    pub fn SteamNetworkingIdentity_SetIPAddr(
        this: *mut SteamNetworkingIdentity,
        addr: *const SteamNetworkingIPAddr,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23SteamNetworkingIdentity9GetIPAddrEv"]
    pub fn SteamNetworkingIdentity_GetIPAddr(
        this: *const SteamNetworkingIdentity,
    ) -> *const SteamNetworkingIPAddr;
}
extern "C" {
    #[link_name = "\u{1}_ZN23SteamNetworkingIdentity11SetIPv4AddrEjt"]
    pub fn SteamNetworkingIdentity_SetIPv4Addr(
        this: *mut SteamNetworkingIdentity,
        nIPv4: uint32,
        nPort: uint16,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23SteamNetworkingIdentity7GetIPv4Ev"]
    pub fn SteamNetworkingIdentity_GetIPv4(this: *const SteamNetworkingIdentity) -> uint32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23SteamNetworkingIdentity13GetFakeIPTypeEv"]
    pub fn SteamNetworkingIdentity_GetFakeIPType(
        this: *const SteamNetworkingIdentity,
    ) -> ESteamNetworkingFakeIPType;
}
extern "C" {
    #[link_name = "\u{1}_ZN23SteamNetworkingIdentity12SetLocalHostEv"]
    pub fn SteamNetworkingIdentity_SetLocalHost(this: *mut SteamNetworkingIdentity);
}
extern "C" {
    #[link_name = "\u{1}_ZNK23SteamNetworkingIdentity11IsLocalHostEv"]
    pub fn SteamNetworkingIdentity_IsLocalHost(this: *const SteamNetworkingIdentity) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN23SteamNetworkingIdentity16SetGenericStringEPKc"]
    pub fn SteamNetworkingIdentity_SetGenericString(
        this: *mut SteamNetworkingIdentity,
        pszString: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23SteamNetworkingIdentity16GetGenericStringEv"]
    pub fn SteamNetworkingIdentity_GetGenericString(
        this: *const SteamNetworkingIdentity,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN23SteamNetworkingIdentity15SetGenericBytesEPKvm"]
    pub fn SteamNetworkingIdentity_SetGenericBytes(
        this: *mut SteamNetworkingIdentity,
        data: *const ::std::os::raw::c_void,
        cbLen: size_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23SteamNetworkingIdentity15GetGenericBytesERi"]
    pub fn SteamNetworkingIdentity_GetGenericBytes(
        this: *const SteamNetworkingIdentity,
        cbLen: *mut ::std::os::raw::c_int,
    ) -> *const uint8;
}
extern "C" {
    #[doc = " Print to a human-readable string.  This is suitable for debug messages"]
    #[doc = " or any other time you need to encode the identity as a string.  It has a"]
    #[doc = " URL-like format (type:<type-data>).  Your buffer should be at least"]
    #[doc = " k_cchMaxString bytes big to avoid truncation."]
    #[doc = ""]
    #[doc = " See also SteamNetworkingIPAddrRender"]
    #[link_name = "\u{1}_ZNK23SteamNetworkingIdentity8ToStringEPcm"]
    pub fn SteamNetworkingIdentity_ToString(
        this: *const SteamNetworkingIdentity,
        buf: *mut ::std::os::raw::c_char,
        cbBuf: size_t,
    );
}
extern "C" {
    #[doc = " Parse back a string that was generated using ToString.  If we don't understand the"]
    #[doc = " string, but it looks \"reasonable\" (it matches the pattern type:<type-data> and doesn't"]
    #[doc = " have any funky characters, etc), then we will return true, and the type is set to"]
    #[doc = " k_ESteamNetworkingIdentityType_UnknownType.  false will only be returned if the string"]
    #[doc = " looks invalid."]
    #[link_name = "\u{1}_ZN23SteamNetworkingIdentity11ParseStringEPKc"]
    pub fn SteamNetworkingIdentity_ParseString(
        this: *mut SteamNetworkingIdentity,
        pszStr: *const ::std::os::raw::c_char,
    ) -> bool;
}
impl Default for SteamNetworkingIdentity {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl SteamNetworkingIdentity {
    #[inline]
    pub unsafe fn Clear(&mut self) {
        SteamNetworkingIdentity_Clear(self)
    }
    #[inline]
    pub unsafe fn IsInvalid(&self) -> bool {
        SteamNetworkingIdentity_IsInvalid(self)
    }
    #[inline]
    pub unsafe fn SetSteamID(&mut self, steamID: CSteamID) {
        SteamNetworkingIdentity_SetSteamID(self, steamID)
    }
    #[inline]
    pub unsafe fn GetSteamID(&self) -> CSteamID {
        SteamNetworkingIdentity_GetSteamID(self)
    }
    #[inline]
    pub unsafe fn SetSteamID64(&mut self, steamID: uint64) {
        SteamNetworkingIdentity_SetSteamID64(self, steamID)
    }
    #[inline]
    pub unsafe fn GetSteamID64(&self) -> uint64 {
        SteamNetworkingIdentity_GetSteamID64(self)
    }
    #[inline]
    pub unsafe fn SetIPAddr(&mut self, addr: *const SteamNetworkingIPAddr) {
        SteamNetworkingIdentity_SetIPAddr(self, addr)
    }
    #[inline]
    pub unsafe fn GetIPAddr(&self) -> *const SteamNetworkingIPAddr {
        SteamNetworkingIdentity_GetIPAddr(self)
    }
    #[inline]
    pub unsafe fn SetIPv4Addr(&mut self, nIPv4: uint32, nPort: uint16) {
        SteamNetworkingIdentity_SetIPv4Addr(self, nIPv4, nPort)
    }
    #[inline]
    pub unsafe fn GetIPv4(&self) -> uint32 {
        SteamNetworkingIdentity_GetIPv4(self)
    }
    #[inline]
    pub unsafe fn GetFakeIPType(&self) -> ESteamNetworkingFakeIPType {
        SteamNetworkingIdentity_GetFakeIPType(self)
    }
    #[inline]
    pub unsafe fn SetLocalHost(&mut self) {
        SteamNetworkingIdentity_SetLocalHost(self)
    }
    #[inline]
    pub unsafe fn IsLocalHost(&self) -> bool {
        SteamNetworkingIdentity_IsLocalHost(self)
    }
    #[inline]
    pub unsafe fn SetGenericString(&mut self, pszString: *const ::std::os::raw::c_char) -> bool {
        SteamNetworkingIdentity_SetGenericString(self, pszString)
    }
    #[inline]
    pub unsafe fn GetGenericString(&self) -> *const ::std::os::raw::c_char {
        SteamNetworkingIdentity_GetGenericString(self)
    }
    #[inline]
    pub unsafe fn SetGenericBytes(
        &mut self,
        data: *const ::std::os::raw::c_void,
        cbLen: size_t,
    ) -> bool {
        SteamNetworkingIdentity_SetGenericBytes(self, data, cbLen)
    }
    #[inline]
    pub unsafe fn GetGenericBytes(&self, cbLen: *mut ::std::os::raw::c_int) -> *const uint8 {
        SteamNetworkingIdentity_GetGenericBytes(self, cbLen)
    }
    #[inline]
    pub unsafe fn ToString(&self, buf: *mut ::std::os::raw::c_char, cbBuf: size_t) {
        SteamNetworkingIdentity_ToString(self, buf, cbBuf)
    }
    #[inline]
    pub unsafe fn ParseString(&mut self, pszStr: *const ::std::os::raw::c_char) -> bool {
        SteamNetworkingIdentity_ParseString(self, pszStr)
    }
}
#[repr(i32)]
#[doc = " High level connection status"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum ESteamNetworkingConnectionState {
    #[doc = " Dummy value used to indicate an error condition in the API."]
    #[doc = " Specified connection doesn't exist or has already been closed."]
    k_ESteamNetworkingConnectionState_None = 0,
    #[doc = " We are trying to establish whether peers can talk to each other,"]
    #[doc = " whether they WANT to talk to each other, perform basic auth,"]
    #[doc = " and exchange crypt keys."]
    #[doc = ""]
    #[doc = " - For connections on the \"client\" side (initiated locally):"]
    #[doc = "   We're in the process of trying to establish a connection."]
    #[doc = "   Depending on the connection type, we might not know who they are."]
    #[doc = "   Note that it is not possible to tell if we are waiting on the"]
    #[doc = "   network to complete handshake packets, or for the application layer"]
    #[doc = "   to accept the connection."]
    #[doc = ""]
    #[doc = " - For connections on the \"server\" side (accepted through listen socket):"]
    #[doc = "   We have completed some basic handshake and the client has presented"]
    #[doc = "   some proof of identity.  The connection is ready to be accepted"]
    #[doc = "   using AcceptConnection()."]
    #[doc = ""]
    #[doc = " In either case, any unreliable packets sent now are almost certain"]
    #[doc = " to be dropped.  Attempts to receive packets are guaranteed to fail."]
    #[doc = " You may send messages if the send mode allows for them to be queued."]
    #[doc = " but if you close the connection before the connection is actually"]
    #[doc = " established, any queued messages will be discarded immediately."]
    #[doc = " (We will not attempt to flush the queue and confirm delivery to the"]
    #[doc = " remote host, which ordinarily happens when a connection is closed.)"]
    k_ESteamNetworkingConnectionState_Connecting = 1,
    #[doc = " Some connection types use a back channel or trusted 3rd party"]
    #[doc = " for earliest communication.  If the server accepts the connection,"]
    #[doc = " then these connections switch into the rendezvous state.  During this"]
    #[doc = " state, we still have not yet established an end-to-end route (through"]
    #[doc = " the relay network), and so if you send any messages unreliable, they"]
    #[doc = " are going to be discarded."]
    k_ESteamNetworkingConnectionState_FindingRoute = 2,
    #[doc = " We've received communications from our peer (and we know"]
    #[doc = " who they are) and are all good.  If you close the connection now,"]
    #[doc = " we will make our best effort to flush out any reliable sent data that"]
    #[doc = " has not been acknowledged by the peer.  (But note that this happens"]
    #[doc = " from within the application process, so unlike a TCP connection, you are"]
    #[doc = " not totally handing it off to the operating system to deal with it.)"]
    k_ESteamNetworkingConnectionState_Connected = 3,
    #[doc = " Connection has been closed by our peer, but not closed locally."]
    #[doc = " The connection still exists from an API perspective.  You must close the"]
    #[doc = " handle to free up resources.  If there are any messages in the inbound queue,"]
    #[doc = " you may retrieve them.  Otherwise, nothing may be done with the connection"]
    #[doc = " except to close it."]
    #[doc = ""]
    #[doc = " This stats is similar to CLOSE_WAIT in the TCP state machine."]
    k_ESteamNetworkingConnectionState_ClosedByPeer = 4,
    #[doc = " A disruption in the connection has been detected locally.  (E.g. timeout,"]
    #[doc = " local internet connection disrupted, etc.)"]
    #[doc = ""]
    #[doc = " The connection still exists from an API perspective.  You must close the"]
    #[doc = " handle to free up resources."]
    #[doc = ""]
    #[doc = " Attempts to send further messages will fail.  Any remaining received messages"]
    #[doc = " in the queue are available."]
    k_ESteamNetworkingConnectionState_ProblemDetectedLocally = 5,
    #[doc = " We've disconnected on our side, and from an API perspective the connection is closed."]
    #[doc = " No more data may be sent or received.  All reliable data has been flushed, or else"]
    #[doc = " we've given up and discarded it.  We do not yet know for sure that the peer knows"]
    #[doc = " the connection has been closed, however, so we're just hanging around so that if we do"]
    #[doc = " get a packet from them, we can send them the appropriate packets so that they can"]
    #[doc = " know why the connection was closed (and not have to rely on a timeout, which makes"]
    #[doc = " it appear as if something is wrong)."]
    k_ESteamNetworkingConnectionState_FinWait = -1,
    #[doc = " We've disconnected on our side, and from an API perspective the connection is closed."]
    #[doc = " No more data may be sent or received.  From a network perspective, however, on the wire,"]
    #[doc = " we have not yet given any indication to the peer that the connection is closed."]
    #[doc = " We are in the process of flushing out the last bit of reliable data.  Once that is done,"]
    #[doc = " we will inform the peer that the connection has been closed, and transition to the"]
    #[doc = " FinWait state."]
    #[doc = ""]
    #[doc = " Note that no indication is given to the remote host that we have closed the connection,"]
    #[doc = " until the data has been flushed.  If the remote host attempts to send us data, we will"]
    #[doc = " do whatever is necessary to keep the connection alive until it can be closed properly."]
    #[doc = " But in fact the data will be discarded, since there is no way for the application to"]
    #[doc = " read it back.  Typically this is not a problem, as application protocols that utilize"]
    #[doc = " the lingering functionality are designed for the remote host to wait for the response"]
    #[doc = " before sending any more data."]
    k_ESteamNetworkingConnectionState_Linger = -2,
    #[doc = " Connection is completely inactive and ready to be destroyed"]
    k_ESteamNetworkingConnectionState_Dead = -3,
    #[doc = " Connection is completely inactive and ready to be destroyed"]
    k_ESteamNetworkingConnectionState__Force32Bit = 2147483647,
}
impl ESteamNetConnectionEnd {
    pub const k_ESteamNetConnectionEnd_App_Generic: ESteamNetConnectionEnd =
        ESteamNetConnectionEnd::k_ESteamNetConnectionEnd_App_Min;
}
impl ESteamNetConnectionEnd {
    pub const k_ESteamNetConnectionEnd_AppException_Generic: ESteamNetConnectionEnd =
        ESteamNetConnectionEnd::k_ESteamNetConnectionEnd_AppException_Min;
}
#[repr(u32)]
#[doc = " Enumerate various causes of connection termination.  These are designed to work similar"]
#[doc = " to HTTP error codes: the numeric range gives you a rough classification as to the source"]
#[doc = " of the problem."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum ESteamNetConnectionEnd {
    k_ESteamNetConnectionEnd_Invalid = 0,
    k_ESteamNetConnectionEnd_App_Min = 1000,
    k_ESteamNetConnectionEnd_App_Max = 1999,
    k_ESteamNetConnectionEnd_AppException_Min = 2000,
    k_ESteamNetConnectionEnd_AppException_Max = 2999,
    k_ESteamNetConnectionEnd_Local_Min = 3000,
    k_ESteamNetConnectionEnd_Local_OfflineMode = 3001,
    k_ESteamNetConnectionEnd_Local_ManyRelayConnectivity = 3002,
    k_ESteamNetConnectionEnd_Local_HostedServerPrimaryRelay = 3003,
    k_ESteamNetConnectionEnd_Local_NetworkConfig = 3004,
    k_ESteamNetConnectionEnd_Local_Rights = 3005,
    k_ESteamNetConnectionEnd_Local_P2P_ICE_NoPublicAddresses = 3006,
    k_ESteamNetConnectionEnd_Local_Max = 3999,
    k_ESteamNetConnectionEnd_Remote_Min = 4000,
    k_ESteamNetConnectionEnd_Remote_Timeout = 4001,
    k_ESteamNetConnectionEnd_Remote_BadCrypt = 4002,
    k_ESteamNetConnectionEnd_Remote_BadCert = 4003,
    k_ESteamNetConnectionEnd_Remote_BadProtocolVersion = 4006,
    k_ESteamNetConnectionEnd_Remote_P2P_ICE_NoPublicAddresses = 4007,
    k_ESteamNetConnectionEnd_Remote_Max = 4999,
    k_ESteamNetConnectionEnd_Misc_Min = 5000,
    k_ESteamNetConnectionEnd_Misc_Generic = 5001,
    k_ESteamNetConnectionEnd_Misc_InternalError = 5002,
    k_ESteamNetConnectionEnd_Misc_Timeout = 5003,
    k_ESteamNetConnectionEnd_Misc_SteamConnectivity = 5005,
    k_ESteamNetConnectionEnd_Misc_NoRelaySessionsToClient = 5006,
    k_ESteamNetConnectionEnd_Misc_P2P_Rendezvous = 5008,
    k_ESteamNetConnectionEnd_Misc_P2P_NAT_Firewall = 5009,
    k_ESteamNetConnectionEnd_Misc_PeerSentNoConnection = 5010,
    k_ESteamNetConnectionEnd_Misc_Max = 5999,
    k_ESteamNetConnectionEnd__Force32Bit = 2147483647,
}
#[doc = " Max length, in bytes (including null terminator) of the reason string"]
#[doc = " when a connection is closed."]
pub const k_cchSteamNetworkingMaxConnectionCloseReason: ::std::os::raw::c_int = 128;
#[doc = " Max length, in bytes (include null terminator) of debug description"]
#[doc = " of a connection."]
pub const k_cchSteamNetworkingMaxConnectionDescription: ::std::os::raw::c_int = 128;
#[doc = " Max length of the app's part of the description"]
pub const k_cchSteamNetworkingMaxConnectionAppName: ::std::os::raw::c_int = 32;
pub const k_nSteamNetworkConnectionInfoFlags_Unauthenticated: ::std::os::raw::c_int = 1;
pub const k_nSteamNetworkConnectionInfoFlags_Unencrypted: ::std::os::raw::c_int = 2;
pub const k_nSteamNetworkConnectionInfoFlags_LoopbackBuffers: ::std::os::raw::c_int = 4;
pub const k_nSteamNetworkConnectionInfoFlags_Fast: ::std::os::raw::c_int = 8;
pub const k_nSteamNetworkConnectionInfoFlags_Relayed: ::std::os::raw::c_int = 16;
pub const k_nSteamNetworkConnectionInfoFlags_DualWifi: ::std::os::raw::c_int = 32;
#[doc = " Describe the state of a connection."]
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct SteamNetConnectionInfo_t {
    #[doc = " Who is on the other end?  Depending on the connection type and phase of the connection, we might not know"]
    pub m_identityRemote: SteamNetworkingIdentity,
    #[doc = " Arbitrary user data set by the local application code"]
    pub m_nUserData: int64,
    #[doc = " Handle to listen socket this was connected on, or k_HSteamListenSocket_Invalid if we initiated the connection"]
    pub m_hListenSocket: HSteamListenSocket,
    #[doc = " Remote address.  Might be all 0's if we don't know it, or if this is N/A."]
    #[doc = " (E.g. Basically everything except direct UDP connection.)"]
    pub m_addrRemote: SteamNetworkingIPAddr,
    pub m__pad1: uint16,
    #[doc = " What data center is the remote host in?  (0 if we don't know.)"]
    pub m_idPOPRemote: SteamNetworkingPOPID,
    #[doc = " What relay are we using to communicate with the remote host?"]
    #[doc = " (0 if not applicable.)"]
    pub m_idPOPRelay: SteamNetworkingPOPID,
    #[doc = " High level state of the connection"]
    pub m_eState: ESteamNetworkingConnectionState,
    #[doc = " Basic cause of the connection termination or problem."]
    #[doc = " See ESteamNetConnectionEnd for the values used"]
    pub m_eEndReason: ::std::os::raw::c_int,
    #[doc = " Human-readable, but non-localized explanation for connection"]
    #[doc = " termination or problem.  This is intended for debugging /"]
    #[doc = " diagnostic purposes only, not to display to users.  It might"]
    #[doc = " have some details specific to the issue."]
    pub m_szEndDebug: [::std::os::raw::c_char; 128usize],
    #[doc = " Debug description.  This includes the internal connection ID,"]
    #[doc = " connection type (and peer information), and any name"]
    #[doc = " given to the connection by the app.  This string is used in various"]
    #[doc = " internal logging messages."]
    pub m_szConnectionDescription: [::std::os::raw::c_char; 128usize],
    #[doc = " Misc flags.  Bitmask of k_nSteamNetworkConnectionInfoFlags_Xxxx"]
    pub m_nFlags: ::std::os::raw::c_int,
    #[doc = " Internal stuff, room to change API easily"]
    pub reserved: [uint32; 63usize],
}
#[test]
fn bindgen_test_layout_SteamNetConnectionInfo_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamNetConnectionInfo_t>(),
        696usize,
        concat!("Size of: ", stringify!(SteamNetConnectionInfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetConnectionInfo_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamNetConnectionInfo_t))
    );
    fn test_field_m_identityRemote() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetConnectionInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_identityRemote) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionInfo_t),
                "::",
                stringify!(m_identityRemote)
            )
        );
    }
    test_field_m_identityRemote();
    fn test_field_m_nUserData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetConnectionInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_nUserData) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionInfo_t),
                "::",
                stringify!(m_nUserData)
            )
        );
    }
    test_field_m_nUserData();
    fn test_field_m_hListenSocket() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetConnectionInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_hListenSocket) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionInfo_t),
                "::",
                stringify!(m_hListenSocket)
            )
        );
    }
    test_field_m_hListenSocket();
    fn test_field_m_addrRemote() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetConnectionInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_addrRemote) as usize - ptr as usize
            },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionInfo_t),
                "::",
                stringify!(m_addrRemote)
            )
        );
    }
    test_field_m_addrRemote();
    fn test_field_m__pad1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetConnectionInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m__pad1) as usize - ptr as usize
            },
            166usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionInfo_t),
                "::",
                stringify!(m__pad1)
            )
        );
    }
    test_field_m__pad1();
    fn test_field_m_idPOPRemote() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetConnectionInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_idPOPRemote) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionInfo_t),
                "::",
                stringify!(m_idPOPRemote)
            )
        );
    }
    test_field_m_idPOPRemote();
    fn test_field_m_idPOPRelay() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetConnectionInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_idPOPRelay) as usize - ptr as usize
            },
            172usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionInfo_t),
                "::",
                stringify!(m_idPOPRelay)
            )
        );
    }
    test_field_m_idPOPRelay();
    fn test_field_m_eState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetConnectionInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_eState) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionInfo_t),
                "::",
                stringify!(m_eState)
            )
        );
    }
    test_field_m_eState();
    fn test_field_m_eEndReason() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetConnectionInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_eEndReason) as usize - ptr as usize
            },
            180usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionInfo_t),
                "::",
                stringify!(m_eEndReason)
            )
        );
    }
    test_field_m_eEndReason();
    fn test_field_m_szEndDebug() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetConnectionInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_szEndDebug) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionInfo_t),
                "::",
                stringify!(m_szEndDebug)
            )
        );
    }
    test_field_m_szEndDebug();
    fn test_field_m_szConnectionDescription() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetConnectionInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_szConnectionDescription) as usize - ptr as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionInfo_t),
                "::",
                stringify!(m_szConnectionDescription)
            )
        );
    }
    test_field_m_szConnectionDescription();
    fn test_field_m_nFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetConnectionInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_nFlags) as usize - ptr as usize
            },
            440usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionInfo_t),
                "::",
                stringify!(m_nFlags)
            )
        );
    }
    test_field_m_nFlags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetConnectionInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            444usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionInfo_t),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
impl Default for SteamNetConnectionInfo_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Quick connection state, pared down to something you could call"]
#[doc = " more frequently without it being too big of a perf hit."]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct SteamNetConnectionRealTimeStatus_t {
    #[doc = " High level state of the connection"]
    pub m_eState: ESteamNetworkingConnectionState,
    #[doc = " Current ping (ms)"]
    pub m_nPing: ::std::os::raw::c_int,
    #[doc = " Connection quality measured locally, 0...1.  (Percentage of packets delivered"]
    #[doc = " end-to-end in order)."]
    pub m_flConnectionQualityLocal: f32,
    #[doc = " Packet delivery success rate as observed from remote host"]
    pub m_flConnectionQualityRemote: f32,
    #[doc = " Current data rates from recent history."]
    pub m_flOutPacketsPerSec: f32,
    pub m_flOutBytesPerSec: f32,
    pub m_flInPacketsPerSec: f32,
    pub m_flInBytesPerSec: f32,
    #[doc = " Estimate rate that we believe that we can send data to our peer."]
    #[doc = " Note that this could be significantly higher than m_flOutBytesPerSec,"]
    #[doc = " meaning the capacity of the channel is higher than you are sending data."]
    #[doc = " (That's OK!)"]
    pub m_nSendRateBytesPerSecond: ::std::os::raw::c_int,
    #[doc = " Number of bytes pending to be sent.  This is data that you have recently"]
    #[doc = " requested to be sent but has not yet actually been put on the wire.  The"]
    #[doc = " reliable number ALSO includes data that was previously placed on the wire,"]
    #[doc = " but has now been scheduled for re-transmission.  Thus, it's possible to"]
    #[doc = " observe m_cbPendingReliable increasing between two checks, even if no"]
    #[doc = " calls were made to send reliable data between the checks.  Data that is"]
    #[doc = " awaiting the Nagle delay will appear in these numbers."]
    pub m_cbPendingUnreliable: ::std::os::raw::c_int,
    pub m_cbPendingReliable: ::std::os::raw::c_int,
    #[doc = " Number of bytes of reliable data that has been placed the wire, but"]
    #[doc = " for which we have not yet received an acknowledgment, and thus we may"]
    #[doc = " have to re-transmit."]
    pub m_cbSentUnackedReliable: ::std::os::raw::c_int,
    #[doc = " If you queued a message right now, approximately how long would that message"]
    #[doc = " wait in the queue before we actually started putting its data on the wire in"]
    #[doc = " a packet?"]
    #[doc = ""]
    #[doc = " In general, data that is sent by the application is limited by the bandwidth"]
    #[doc = " of the channel.  If you send data faster than this, it must be queued and"]
    #[doc = " put on the wire at a metered rate.  Even sending a small amount of data (e.g."]
    #[doc = " a few MTU, say ~3k) will require some of the data to be delayed a bit."]
    #[doc = ""]
    #[doc = " Ignoring multiple lanes, the estimated delay will be approximately equal to"]
    #[doc = ""]
    #[doc = "\t\t( m_cbPendingUnreliable+m_cbPendingReliable ) / m_nSendRateBytesPerSecond"]
    #[doc = ""]
    #[doc = " plus or minus one MTU.  It depends on how much time has elapsed since the last"]
    #[doc = " packet was put on the wire.  For example, the queue might have *just* been emptied,"]
    #[doc = " and the last packet placed on the wire, and we are exactly up against the send"]
    #[doc = " rate limit.  In that case we might need to wait for one packet's worth of time to"]
    #[doc = " elapse before we can send again.  On the other extreme, the queue might have data"]
    #[doc = " in it waiting for Nagle.  (This will always be less than one packet, because as"]
    #[doc = " soon as we have a complete packet we would send it.)  In that case, we might be"]
    #[doc = " ready to send data now, and this value will be 0."]
    #[doc = ""]
    #[doc = " This value is only valid if multiple lanes are not used.  If multiple lanes are"]
    #[doc = " in use, then the queue time will be different for each lane, and you must use"]
    #[doc = " the value in SteamNetConnectionRealTimeLaneStatus_t."]
    #[doc = ""]
    #[doc = " Nagle delay is ignored for the purposes of this calculation."]
    pub m_usecQueueTime: SteamNetworkingMicroseconds,
    pub reserved: [uint32; 16usize],
}
#[test]
fn bindgen_test_layout_SteamNetConnectionRealTimeStatus_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamNetConnectionRealTimeStatus_t>(),
        120usize,
        concat!("Size of: ", stringify!(SteamNetConnectionRealTimeStatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetConnectionRealTimeStatus_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetConnectionRealTimeStatus_t)
        )
    );
    fn test_field_m_eState() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionRealTimeStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_eState) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionRealTimeStatus_t),
                "::",
                stringify!(m_eState)
            )
        );
    }
    test_field_m_eState();
    fn test_field_m_nPing() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionRealTimeStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_nPing) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionRealTimeStatus_t),
                "::",
                stringify!(m_nPing)
            )
        );
    }
    test_field_m_nPing();
    fn test_field_m_flConnectionQualityLocal() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionRealTimeStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_flConnectionQualityLocal) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionRealTimeStatus_t),
                "::",
                stringify!(m_flConnectionQualityLocal)
            )
        );
    }
    test_field_m_flConnectionQualityLocal();
    fn test_field_m_flConnectionQualityRemote() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionRealTimeStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_flConnectionQualityRemote) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionRealTimeStatus_t),
                "::",
                stringify!(m_flConnectionQualityRemote)
            )
        );
    }
    test_field_m_flConnectionQualityRemote();
    fn test_field_m_flOutPacketsPerSec() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionRealTimeStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_flOutPacketsPerSec) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionRealTimeStatus_t),
                "::",
                stringify!(m_flOutPacketsPerSec)
            )
        );
    }
    test_field_m_flOutPacketsPerSec();
    fn test_field_m_flOutBytesPerSec() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionRealTimeStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_flOutBytesPerSec) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionRealTimeStatus_t),
                "::",
                stringify!(m_flOutBytesPerSec)
            )
        );
    }
    test_field_m_flOutBytesPerSec();
    fn test_field_m_flInPacketsPerSec() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionRealTimeStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_flInPacketsPerSec) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionRealTimeStatus_t),
                "::",
                stringify!(m_flInPacketsPerSec)
            )
        );
    }
    test_field_m_flInPacketsPerSec();
    fn test_field_m_flInBytesPerSec() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionRealTimeStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_flInBytesPerSec) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionRealTimeStatus_t),
                "::",
                stringify!(m_flInBytesPerSec)
            )
        );
    }
    test_field_m_flInBytesPerSec();
    fn test_field_m_nSendRateBytesPerSecond() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionRealTimeStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_nSendRateBytesPerSecond) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionRealTimeStatus_t),
                "::",
                stringify!(m_nSendRateBytesPerSecond)
            )
        );
    }
    test_field_m_nSendRateBytesPerSecond();
    fn test_field_m_cbPendingUnreliable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionRealTimeStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_cbPendingUnreliable) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionRealTimeStatus_t),
                "::",
                stringify!(m_cbPendingUnreliable)
            )
        );
    }
    test_field_m_cbPendingUnreliable();
    fn test_field_m_cbPendingReliable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionRealTimeStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_cbPendingReliable) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionRealTimeStatus_t),
                "::",
                stringify!(m_cbPendingReliable)
            )
        );
    }
    test_field_m_cbPendingReliable();
    fn test_field_m_cbSentUnackedReliable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionRealTimeStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_cbSentUnackedReliable) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionRealTimeStatus_t),
                "::",
                stringify!(m_cbSentUnackedReliable)
            )
        );
    }
    test_field_m_cbSentUnackedReliable();
    fn test_field_m_usecQueueTime() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionRealTimeStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_usecQueueTime) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionRealTimeStatus_t),
                "::",
                stringify!(m_usecQueueTime)
            )
        );
    }
    test_field_m_usecQueueTime();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionRealTimeStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionRealTimeStatus_t),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
impl Default for SteamNetConnectionRealTimeStatus_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Quick status of a particular lane"]
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct SteamNetConnectionRealTimeLaneStatus_t {
    pub m_cbPendingUnreliable: ::std::os::raw::c_int,
    pub m_cbPendingReliable: ::std::os::raw::c_int,
    pub m_cbSentUnackedReliable: ::std::os::raw::c_int,
    pub _reservePad1: ::std::os::raw::c_int,
    #[doc = " Lane-specific queue time.  This value takes into consideration lane priorities"]
    #[doc = " and weights, and how much data is queued in each lane, and attempts to predict"]
    #[doc = " how any data currently queued will be sent out."]
    pub m_usecQueueTime: SteamNetworkingMicroseconds,
    pub reserved: [uint32; 10usize],
}
#[test]
fn bindgen_test_layout_SteamNetConnectionRealTimeLaneStatus_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamNetConnectionRealTimeLaneStatus_t>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetConnectionRealTimeLaneStatus_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t)
        )
    );
    fn test_field_m_cbPendingUnreliable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionRealTimeLaneStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_cbPendingUnreliable) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionRealTimeLaneStatus_t),
                "::",
                stringify!(m_cbPendingUnreliable)
            )
        );
    }
    test_field_m_cbPendingUnreliable();
    fn test_field_m_cbPendingReliable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionRealTimeLaneStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_cbPendingReliable) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionRealTimeLaneStatus_t),
                "::",
                stringify!(m_cbPendingReliable)
            )
        );
    }
    test_field_m_cbPendingReliable();
    fn test_field_m_cbSentUnackedReliable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionRealTimeLaneStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_cbSentUnackedReliable) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionRealTimeLaneStatus_t),
                "::",
                stringify!(m_cbSentUnackedReliable)
            )
        );
    }
    test_field_m_cbSentUnackedReliable();
    fn test_field__reservePad1() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionRealTimeLaneStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._reservePad1) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionRealTimeLaneStatus_t),
                "::",
                stringify!(_reservePad1)
            )
        );
    }
    test_field__reservePad1();
    fn test_field_m_usecQueueTime() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionRealTimeLaneStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_usecQueueTime) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionRealTimeLaneStatus_t),
                "::",
                stringify!(m_usecQueueTime)
            )
        );
    }
    test_field_m_usecQueueTime();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionRealTimeLaneStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionRealTimeLaneStatus_t),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[doc = " Max size of a single message that we can SEND."]
#[doc = " Note: We might be wiling to receive larger messages,"]
#[doc = " and our peer might, too."]
pub const k_cbMaxSteamNetworkingSocketsMessageSizeSend: ::std::os::raw::c_int = 524288;
#[doc = " A message that has been received."]
#[repr(C)]
pub struct SteamNetworkingMessage_t {
    #[doc = " Message payload"]
    pub m_pData: *mut ::std::os::raw::c_void,
    #[doc = " Size of the payload."]
    pub m_cbSize: ::std::os::raw::c_int,
    #[doc = " For messages received on connections: what connection did this come from?"]
    #[doc = " For outgoing messages: what connection to send it to?"]
    #[doc = " Not used when using the ISteamNetworkingMessages interface"]
    pub m_conn: HSteamNetConnection,
    #[doc = " For inbound messages: Who sent this to us?"]
    #[doc = " For outbound messages on connections: not used."]
    #[doc = " For outbound messages on the ad-hoc ISteamNetworkingMessages interface: who should we send this to?"]
    pub m_identityPeer: SteamNetworkingIdentity,
    #[doc = " For messages received on connections, this is the user data"]
    #[doc = " associated with the connection."]
    #[doc = ""]
    #[doc = " This is *usually* the same as calling GetConnection() and then"]
    #[doc = " fetching the user data associated with that connection, but for"]
    #[doc = " the following subtle differences:"]
    #[doc = ""]
    #[doc = " - This user data will match the connection's user data at the time"]
    #[doc = "   is captured at the time the message is returned by the API."]
    #[doc = "   If you subsequently change the userdata on the connection,"]
    #[doc = "   this won't be updated."]
    #[doc = " - This is an inline call, so it's *much* faster."]
    #[doc = " - You might have closed the connection, so fetching the user data"]
    #[doc = "   would not be possible."]
    #[doc = ""]
    #[doc = " Not used when sending messages."]
    pub m_nConnUserData: int64,
    #[doc = " Local timestamp when the message was received"]
    #[doc = " Not used for outbound messages."]
    pub m_usecTimeReceived: SteamNetworkingMicroseconds,
    #[doc = " Message number assigned by the sender.  This is not used for outbound"]
    #[doc = " messages.  Note that if multiple lanes are used, each lane has its own"]
    #[doc = " message numbers, which are assigned sequentially, so messages from"]
    #[doc = " different lanes will share the same numbers."]
    pub m_nMessageNumber: int64,
    #[doc = " Function used to free up m_pData.  This mechanism exists so that"]
    #[doc = " apps can create messages with buffers allocated from their own"]
    #[doc = " heap, and pass them into the library.  This function will"]
    #[doc = " usually be something like:"]
    #[doc = ""]
    #[doc = " free( pMsg->m_pData );"]
    pub m_pfnFreeData:
        ::std::option::Option<unsafe extern "C" fn(pMsg: *mut SteamNetworkingMessage_t)>,
    #[doc = " Function to used to decrement the internal reference count and, if"]
    #[doc = " it's zero, release the message.  You should not set this function pointer,"]
    #[doc = " or need to access this directly!  Use the Release() function instead!"]
    pub m_pfnRelease:
        ::std::option::Option<unsafe extern "C" fn(pMsg: *mut SteamNetworkingMessage_t)>,
    #[doc = " When using ISteamNetworkingMessages, the channel number the message was received on"]
    #[doc = " (Not used for messages sent or received on \"connections\")"]
    pub m_nChannel: ::std::os::raw::c_int,
    #[doc = " Bitmask of k_nSteamNetworkingSend_xxx flags."]
    #[doc = " For received messages, only the k_nSteamNetworkingSend_Reliable bit is valid."]
    #[doc = " For outbound messages, all bits are relevant"]
    pub m_nFlags: ::std::os::raw::c_int,
    #[doc = " Arbitrary user data that you can use when sending messages using"]
    #[doc = " ISteamNetworkingUtils::AllocateMessage and ISteamNetworkingSockets::SendMessage."]
    #[doc = " (The callback you set in m_pfnFreeData might use this field.)"]
    #[doc = ""]
    #[doc = " Not used for received messages."]
    pub m_nUserData: int64,
    #[doc = " For outbound messages, which lane to use?  See ISteamNetworkingSockets::ConfigureConnectionLanes."]
    #[doc = " For inbound messages, what lane was the message received on?"]
    pub m_idxLane: uint16,
    pub _pad1__: uint16,
}
#[test]
fn bindgen_test_layout_SteamNetworkingMessage_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingMessage_t>(),
        216usize,
        concat!("Size of: ", stringify!(SteamNetworkingMessage_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingMessage_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SteamNetworkingMessage_t))
    );
    fn test_field_m_pData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingMessage_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_pData) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingMessage_t),
                "::",
                stringify!(m_pData)
            )
        );
    }
    test_field_m_pData();
    fn test_field_m_cbSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingMessage_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_cbSize) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingMessage_t),
                "::",
                stringify!(m_cbSize)
            )
        );
    }
    test_field_m_cbSize();
    fn test_field_m_conn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingMessage_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_conn) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingMessage_t),
                "::",
                stringify!(m_conn)
            )
        );
    }
    test_field_m_conn();
    fn test_field_m_identityPeer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingMessage_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_identityPeer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingMessage_t),
                "::",
                stringify!(m_identityPeer)
            )
        );
    }
    test_field_m_identityPeer();
    fn test_field_m_nConnUserData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingMessage_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_nConnUserData) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingMessage_t),
                "::",
                stringify!(m_nConnUserData)
            )
        );
    }
    test_field_m_nConnUserData();
    fn test_field_m_usecTimeReceived() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingMessage_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_usecTimeReceived) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingMessage_t),
                "::",
                stringify!(m_usecTimeReceived)
            )
        );
    }
    test_field_m_usecTimeReceived();
    fn test_field_m_nMessageNumber() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingMessage_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_nMessageNumber) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingMessage_t),
                "::",
                stringify!(m_nMessageNumber)
            )
        );
    }
    test_field_m_nMessageNumber();
    fn test_field_m_pfnFreeData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingMessage_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_pfnFreeData) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingMessage_t),
                "::",
                stringify!(m_pfnFreeData)
            )
        );
    }
    test_field_m_pfnFreeData();
    fn test_field_m_pfnRelease() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingMessage_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_pfnRelease) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingMessage_t),
                "::",
                stringify!(m_pfnRelease)
            )
        );
    }
    test_field_m_pfnRelease();
    fn test_field_m_nChannel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingMessage_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_nChannel) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingMessage_t),
                "::",
                stringify!(m_nChannel)
            )
        );
    }
    test_field_m_nChannel();
    fn test_field_m_nFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingMessage_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_nFlags) as usize - ptr as usize
            },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingMessage_t),
                "::",
                stringify!(m_nFlags)
            )
        );
    }
    test_field_m_nFlags();
    fn test_field_m_nUserData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingMessage_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_nUserData) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingMessage_t),
                "::",
                stringify!(m_nUserData)
            )
        );
    }
    test_field_m_nUserData();
    fn test_field_m_idxLane() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingMessage_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_idxLane) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingMessage_t),
                "::",
                stringify!(m_idxLane)
            )
        );
    }
    test_field_m_idxLane();
    fn test_field__pad1__() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingMessage_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._pad1__) as usize - ptr as usize
            },
            210usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingMessage_t),
                "::",
                stringify!(_pad1__)
            )
        );
    }
    test_field__pad1__();
}
impl Default for SteamNetworkingMessage_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const k_nSteamNetworkingSend_Unreliable: ::std::os::raw::c_int = 0;
pub const k_nSteamNetworkingSend_NoNagle: ::std::os::raw::c_int = 1;
pub const k_nSteamNetworkingSend_UnreliableNoNagle: ::std::os::raw::c_int = 1;
pub const k_nSteamNetworkingSend_NoDelay: ::std::os::raw::c_int = 4;
pub const k_nSteamNetworkingSend_UnreliableNoDelay: ::std::os::raw::c_int = 5;
pub const k_nSteamNetworkingSend_Reliable: ::std::os::raw::c_int = 8;
pub const k_nSteamNetworkingSend_ReliableNoNagle: ::std::os::raw::c_int = 9;
pub const k_nSteamNetworkingSend_UseCurrentThread: ::std::os::raw::c_int = 16;
pub const k_nSteamNetworkingSend_AutoRestartBrokenSession: ::std::os::raw::c_int = 32;
#[doc = " Object that describes a \"location\" on the Internet with sufficient"]
#[doc = " detail that we can reasonably estimate an upper bound on the ping between"]
#[doc = " the two hosts, even if a direct route between the hosts is not possible,"]
#[doc = " and the connection must be routed through the Steam Datagram Relay network."]
#[doc = " This does not contain any information that identifies the host.  Indeed,"]
#[doc = " if two hosts are in the same building or otherwise have nearly identical"]
#[doc = " networking characteristics, then it's valid to use the same location"]
#[doc = " object for both of them."]
#[doc = ""]
#[doc = " NOTE: This object should only be used in the same process!  Do not serialize it,"]
#[doc = " send it over the wire, or persist it in a file or database!  If you need"]
#[doc = " to do that, convert it to a string representation using the methods in"]
#[doc = " ISteamNetworkingUtils()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct SteamNetworkPingLocation_t {
    pub m_data: [uint8; 512usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkPingLocation_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkPingLocation_t>(),
        512usize,
        concat!("Size of: ", stringify!(SteamNetworkPingLocation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkPingLocation_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkPingLocation_t))
    );
    fn test_field_m_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkPingLocation_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkPingLocation_t),
                "::",
                stringify!(m_data)
            )
        );
    }
    test_field_m_data();
}
impl Default for SteamNetworkPingLocation_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Max possible length of a ping location, in string format.  This is"]
#[doc = " an extremely conservative worst case value which leaves room for future"]
#[doc = " syntax enhancements.  Most strings in practice are a lot shorter."]
#[doc = " If you are storing many of these, you will very likely benefit from"]
#[doc = " using dynamic memory."]
pub const k_cchMaxSteamNetworkingPingLocationString: ::std::os::raw::c_int = 1024;
#[doc = " Special values that are returned by some functions that return a ping."]
pub const k_nSteamNetworkingPing_Failed: ::std::os::raw::c_int = -1;
pub const k_nSteamNetworkingPing_Unknown: ::std::os::raw::c_int = -2;
#[repr(u32)]
#[doc = " Configuration values can be applied to different types of objects."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum ESteamNetworkingConfigScope {
    #[doc = " Get/set global option, or defaults.  Even options that apply to more specific scopes"]
    #[doc = " have global scope, and you may be able to just change the global defaults.  If you"]
    #[doc = " need different settings per connection (for example), then you will need to set those"]
    #[doc = " options at the more specific scope."]
    k_ESteamNetworkingConfig_Global = 1,
    #[doc = " Some options are specific to a particular interface.  Note that all connection"]
    #[doc = " and listen socket settings can also be set at the interface level, and they will"]
    #[doc = " apply to objects created through those interfaces."]
    k_ESteamNetworkingConfig_SocketsInterface = 2,
    #[doc = " Options for a listen socket.  Listen socket options can be set at the interface layer,"]
    #[doc = " if  you have multiple listen sockets and they all use the same options."]
    #[doc = " You can also set connection options on a listen socket, and they set the defaults"]
    #[doc = " for all connections accepted through this listen socket.  (They will be used if you don't"]
    #[doc = " set a connection option.)"]
    k_ESteamNetworkingConfig_ListenSocket = 3,
    #[doc = " Options for a specific connection."]
    k_ESteamNetworkingConfig_Connection = 4,
    #[doc = " Options for a specific connection."]
    k_ESteamNetworkingConfigScope__Force32Bit = 2147483647,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum ESteamNetworkingConfigDataType {
    k_ESteamNetworkingConfig_Int32 = 1,
    k_ESteamNetworkingConfig_Int64 = 2,
    k_ESteamNetworkingConfig_Float = 3,
    k_ESteamNetworkingConfig_String = 4,
    k_ESteamNetworkingConfig_Ptr = 5,
    k_ESteamNetworkingConfigDataType__Force32Bit = 2147483647,
}
#[repr(u32)]
#[doc = " Configuration options"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum ESteamNetworkingConfigValue {
    k_ESteamNetworkingConfig_Invalid = 0,
    #[doc = " [connection int32] Timeout value (in ms) to use when first connecting"]
    k_ESteamNetworkingConfig_TimeoutInitial = 24,
    #[doc = " [connection int32] Timeout value (in ms) to use after connection is established"]
    k_ESteamNetworkingConfig_TimeoutConnected = 25,
    #[doc = " [connection int32] Upper limit of buffered pending bytes to be sent,"]
    #[doc = " if this is reached SendMessage will return k_EResultLimitExceeded"]
    #[doc = " Default is 512k (524288 bytes)"]
    k_ESteamNetworkingConfig_SendBufferSize = 9,
    #[doc = " [connection int64] Get/set userdata as a configuration option."]
    #[doc = " The default value is -1.   You may want to set the user data as"]
    #[doc = " a config value, instead of using ISteamNetworkingSockets::SetConnectionUserData"]
    #[doc = " in two specific instances:"]
    #[doc = ""]
    #[doc = " - You wish to set the userdata atomically when creating"]
    #[doc = "   an outbound connection, so that the userdata is filled in properly"]
    #[doc = "   for any callbacks that happen.  However, note that this trick"]
    #[doc = "   only works for connections initiated locally!  For incoming"]
    #[doc = "   connections, multiple state transitions may happen and"]
    #[doc = "   callbacks be queued, before you are able to service the first"]
    #[doc = "   callback!  Be careful!"]
    #[doc = ""]
    #[doc = " - You can set the default userdata for all newly created connections"]
    #[doc = "   by setting this value at a higher level (e.g. on the listen"]
    #[doc = "   socket or at the global level.)  Then this default"]
    #[doc = "   value will be inherited when the connection is created."]
    #[doc = "   This is useful in case -1 is a valid userdata value, and you"]
    #[doc = "   wish to use something else as the default value so you can"]
    #[doc = "   tell if it has been set or not."]
    #[doc = ""]
    #[doc = "   HOWEVER: once a connection is created, the effective value is"]
    #[doc = "   then bound to the connection.  Unlike other connection options,"]
    #[doc = "   if you change it again at a higher level, the new value will not"]
    #[doc = "   be inherited by connections."]
    #[doc = ""]
    #[doc = " Using the userdata field in callback structs is not advised because"]
    #[doc = " of tricky race conditions.  Instead, you might try one of these methods:"]
    #[doc = ""]
    #[doc = " - Use a separate map with the HSteamNetConnection as the key."]
    #[doc = " - Fetch the userdata from the connection in your callback"]
    #[doc = "   using ISteamNetworkingSockets::GetConnectionUserData, to"]
    k_ESteamNetworkingConfig_ConnectionUserData = 40,
    #[doc = " [connection int32] Minimum/maximum send rate clamp, 0 is no limit."]
    #[doc = " This value will control the min/max allowed sending rate that"]
    #[doc = " bandwidth estimation is allowed to reach.  Default is 0 (no-limit)"]
    k_ESteamNetworkingConfig_SendRateMin = 10,
    #[doc = " [connection int32] Minimum/maximum send rate clamp, 0 is no limit."]
    #[doc = " This value will control the min/max allowed sending rate that"]
    #[doc = " bandwidth estimation is allowed to reach.  Default is 0 (no-limit)"]
    k_ESteamNetworkingConfig_SendRateMax = 11,
    #[doc = " [connection int32] Nagle time, in microseconds.  When SendMessage is called, if"]
    #[doc = " the outgoing message is less than the size of the MTU, it will be"]
    #[doc = " queued for a delay equal to the Nagle timer value.  This is to ensure"]
    #[doc = " that if the application sends several small messages rapidly, they are"]
    #[doc = " coalesced into a single packet."]
    #[doc = " See historical RFC 896.  Value is in microseconds."]
    #[doc = " Default is 5000us (5ms)."]
    k_ESteamNetworkingConfig_NagleTime = 12,
    #[doc = " [connection int32] Don't automatically fail IP connections that don't have"]
    #[doc = " strong auth.  On clients, this means we will attempt the connection even if"]
    #[doc = " we don't know our identity or can't get a cert.  On the server, it means that"]
    #[doc = " we won't automatically reject a connection due to a failure to authenticate."]
    #[doc = " (You can examine the incoming connection and decide whether to accept it.)"]
    #[doc = ""]
    #[doc = " This is a dev configuration value, and you should not let users modify it in"]
    #[doc = " production."]
    k_ESteamNetworkingConfig_IP_AllowWithoutAuth = 23,
    #[doc = " [connection int32] Do not send UDP packets with a payload of"]
    #[doc = " larger than N bytes.  If you set this, k_ESteamNetworkingConfig_MTU_DataSize"]
    #[doc = " is automatically adjusted"]
    k_ESteamNetworkingConfig_MTU_PacketSize = 32,
    #[doc = " [connection int32] (read only) Maximum message size you can send that"]
    #[doc = " will not fragment, based on k_ESteamNetworkingConfig_MTU_PacketSize"]
    k_ESteamNetworkingConfig_MTU_DataSize = 33,
    #[doc = " [connection int32] Allow unencrypted (and unauthenticated) communication."]
    #[doc = " 0: Not allowed (the default)"]
    #[doc = " 1: Allowed, but prefer encrypted"]
    #[doc = " 2: Allowed, and preferred"]
    #[doc = " 3: Required.  (Fail the connection if the peer requires encryption.)"]
    #[doc = ""]
    #[doc = " This is a dev configuration value, since its purpose is to disable encryption."]
    #[doc = " You should not let users modify it in production.  (But note that it requires"]
    #[doc = " the peer to also modify their value in order for encryption to be disabled.)"]
    k_ESteamNetworkingConfig_Unencrypted = 34,
    #[doc = " [connection int32] Set this to 1 on outbound connections and listen sockets,"]
    #[doc = " to enable \"symmetric connect mode\", which is useful in the following"]
    #[doc = " common peer-to-peer use case:"]
    #[doc = ""]
    #[doc = " - The two peers are \"equal\" to each other.  (Neither is clearly the \"client\""]
    #[doc = "   or \"server\".)"]
    #[doc = " - Either peer may initiate the connection, and indeed they may do this"]
    #[doc = "   at the same time"]
    #[doc = " - The peers only desire a single connection to each other, and if both"]
    #[doc = "   peers initiate connections simultaneously, a protocol is needed for them"]
    #[doc = "   to resolve the conflict, so that we end up with a single connection."]
    #[doc = ""]
    #[doc = " This use case is both common, and involves subtle race conditions and tricky"]
    #[doc = " pitfalls, which is why the API has support for dealing with it."]
    #[doc = ""]
    #[doc = " If an incoming connection arrives on a listen socket or via custom signaling,"]
    #[doc = " and the application has not attempted to make a matching outbound connection"]
    #[doc = " in symmetric mode, then the incoming connection can be accepted as usual."]
    #[doc = " A \"matching\" connection means that the relevant endpoint information matches."]
    #[doc = " (At the time this comment is being written, this is only supported for P2P"]
    #[doc = " connections, which means that the peer identities must match, and the virtual"]
    #[doc = " port must match.  At a later time, symmetric mode may be supported for other"]
    #[doc = " connection types.)"]
    #[doc = ""]
    #[doc = " If connections are initiated by both peers simultaneously, race conditions"]
    #[doc = " can arise, but fortunately, most of them are handled internally and do not"]
    #[doc = " require any special awareness from the application.  However, there"]
    #[doc = " is one important case that application code must be aware of:"]
    #[doc = " If application code attempts an outbound connection using a ConnectXxx"]
    #[doc = " function in symmetric mode, and a matching incoming connection is already"]
    #[doc = " waiting on a listen socket, then instead of forming a new connection,"]
    #[doc = " the ConnectXxx call will accept the existing incoming connection, and return"]
    #[doc = " a connection handle to this accepted connection."]
    #[doc = " IMPORTANT: in this case, a SteamNetConnectionStatusChangedCallback_t"]
    #[doc = " has probably *already* been posted to the queue for the incoming connection!"]
    #[doc = " (Once callbacks are posted to the queue, they are not modified.)  It doesn't"]
    #[doc = " matter if the callback has not been consumed by the app.  Thus, application"]
    #[doc = " code that makes use of symmetric connections must be aware that, when processing a"]
    #[doc = " SteamNetConnectionStatusChangedCallback_t for an incoming connection, the"]
    #[doc = " m_hConn may refer to a new connection that the app has has not"]
    #[doc = " seen before (the usual case), but it may also refer to a connection that"]
    #[doc = " has already been accepted implicitly through a call to Connect()!  In this"]
    #[doc = " case, AcceptConnection() will return k_EResultDuplicateRequest."]
    #[doc = ""]
    #[doc = " Only one symmetric connection to a given peer (on a given virtual port)"]
    #[doc = " may exist at any given time.  If client code attempts to create a connection,"]
    #[doc = " and a (live) connection already exists on the local host, then either the"]
    #[doc = " existing connection will be accepted as described above, or the attempt"]
    #[doc = " to create a new connection will fail.  Furthermore, linger mode functionality"]
    #[doc = " is not supported on symmetric connections."]
    #[doc = ""]
    #[doc = " A more complicated race condition can arise if both peers initiate a connection"]
    #[doc = " at roughly the same time.  In this situation, each peer will receive an incoming"]
    #[doc = " connection from the other peer, when the application code has already initiated"]
    #[doc = " an outgoing connection to that peer.  The peers must resolve this conflict and"]
    #[doc = " decide who is going to act as the \"server\" and who will act as the \"client\"."]
    #[doc = " Typically the application does not need to be aware of this case as it is handled"]
    #[doc = " internally.  On both sides, the will observe their outbound connection being"]
    #[doc = " \"accepted\", although one of them one have been converted internally to act"]
    #[doc = " as the \"server\"."]
    #[doc = ""]
    #[doc = " In general, symmetric mode should be all-or-nothing: do not mix symmetric"]
    #[doc = " connections with a non-symmetric connection that it might possible \"match\""]
    #[doc = " with.  If you use symmetric mode on any connections, then both peers should"]
    #[doc = " use it on all connections, and the corresponding listen socket, if any.  The"]
    #[doc = " behaviour when symmetric and ordinary connections are mixed is not defined by"]
    #[doc = " this API, and you should not rely on it.  (This advice only applies when connections"]
    #[doc = " might possibly \"match\".  For example, it's OK to use all symmetric mode"]
    #[doc = " connections on one virtual port, and all ordinary, non-symmetric connections"]
    #[doc = " on a different virtual port, as there is no potential for ambiguity.)"]
    #[doc = ""]
    #[doc = " When using the feature, you should set it in the following situations on"]
    #[doc = " applicable objects:"]
    #[doc = ""]
    #[doc = " - When creating an outbound connection using ConnectXxx function"]
    #[doc = " - When creating a listen socket.  (Note that this will automatically cause"]
    #[doc = "   any accepted connections to inherit the flag.)"]
    #[doc = " - When using custom signaling, before accepting an incoming connection."]
    #[doc = ""]
    #[doc = " Setting the flag on listen socket and accepted connections will enable the"]
    #[doc = " API to automatically deal with duplicate incoming connections, even if the"]
    #[doc = " local host has not made any outbound requests.  (In general, such duplicate"]
    #[doc = " requests from a peer are ignored internally and will not be visible to the"]
    #[doc = " application code.  The previous connection must be closed or resolved first.)"]
    k_ESteamNetworkingConfig_SymmetricConnect = 37,
    #[doc = " [connection int32] For connection types that use \"virtual ports\", this can be used"]
    #[doc = " to assign a local virtual port.  For incoming connections, this will always be the"]
    #[doc = " virtual port of the listen socket (or the port requested by the remote host if custom"]
    #[doc = " signaling is used and the connection is accepted), and cannot be changed.  For"]
    #[doc = " connections initiated locally, the local virtual port will default to the same as the"]
    #[doc = " requested remote virtual port, if you do not specify a different option when creating"]
    #[doc = " the connection.  The local port is only relevant for symmetric connections, when"]
    #[doc = " determining if two connections \"match.\"  In this case, if you need the local and remote"]
    #[doc = " port to differ, you can set this value."]
    #[doc = ""]
    #[doc = " You can also read back this value on listen sockets."]
    #[doc = ""]
    #[doc = " This value should not be read or written in any other context."]
    k_ESteamNetworkingConfig_LocalVirtualPort = 38,
    #[doc = " [connection int32] True to enable diagnostics reporting through"]
    #[doc = " generic platform UI.  (Only available on Steam.)"]
    k_ESteamNetworkingConfig_EnableDiagnosticsUI = 46,
    #[doc = " [global float, 0--100] Randomly discard N pct of packets instead of sending/recv"]
    #[doc = " This is a global option only, since it is applied at a low level"]
    #[doc = " where we don't have much context"]
    k_ESteamNetworkingConfig_FakePacketLoss_Send = 2,
    #[doc = " [global float, 0--100] Randomly discard N pct of packets instead of sending/recv"]
    #[doc = " This is a global option only, since it is applied at a low level"]
    #[doc = " where we don't have much context"]
    k_ESteamNetworkingConfig_FakePacketLoss_Recv = 3,
    #[doc = " [global int32].  Delay all outbound/inbound packets by N ms"]
    k_ESteamNetworkingConfig_FakePacketLag_Send = 4,
    #[doc = " [global int32].  Delay all outbound/inbound packets by N ms"]
    k_ESteamNetworkingConfig_FakePacketLag_Recv = 5,
    #[doc = " [global float] 0-100 Percentage of packets we will add additional delay"]
    #[doc = " to (causing them to be reordered)"]
    k_ESteamNetworkingConfig_FakePacketReorder_Send = 6,
    #[doc = " [global float] 0-100 Percentage of packets we will add additional delay"]
    #[doc = " to (causing them to be reordered)"]
    k_ESteamNetworkingConfig_FakePacketReorder_Recv = 7,
    #[doc = " [global int32] Extra delay, in ms, to apply to reordered packets."]
    k_ESteamNetworkingConfig_FakePacketReorder_Time = 8,
    #[doc = " [global float 0--100] Globally duplicate some percentage of packets we send"]
    k_ESteamNetworkingConfig_FakePacketDup_Send = 26,
    #[doc = " [global float 0--100] Globally duplicate some percentage of packets we send"]
    k_ESteamNetworkingConfig_FakePacketDup_Recv = 27,
    #[doc = " [global int32] Amount of delay, in ms, to delay duplicated packets."]
    #[doc = " (We chose a random delay between 0 and this value)"]
    k_ESteamNetworkingConfig_FakePacketDup_TimeMax = 28,
    #[doc = " [global int32] Trace every UDP packet, similar to Wireshark or tcpdump."]
    #[doc = " Value is max number of bytes to dump.  -1 disables tracing."]
    k_ESteamNetworkingConfig_PacketTraceMaxBytes = 41,
    k_ESteamNetworkingConfig_FakeRateLimit_Send_Rate = 42,
    k_ESteamNetworkingConfig_FakeRateLimit_Send_Burst = 43,
    k_ESteamNetworkingConfig_FakeRateLimit_Recv_Rate = 44,
    k_ESteamNetworkingConfig_FakeRateLimit_Recv_Burst = 45,
    #[doc = " [connection FnSteamNetConnectionStatusChanged] Callback that will be invoked"]
    #[doc = " when the state of a connection changes."]
    #[doc = ""]
    #[doc = " IMPORTANT: callbacks are dispatched to the handler that is in effect at the time"]
    #[doc = " the event occurs, which might be in another thread.  For example, immediately after"]
    #[doc = " creating a listen socket, you may receive an incoming connection.  And then immediately"]
    #[doc = " after this, the remote host may close the connection.  All of this could happen"]
    #[doc = " before the function to create the listen socket has returned.  For this reason,"]
    #[doc = " callbacks usually must be in effect at the time of object creation.  This means"]
    #[doc = " you should set them when you are creating the listen socket or connection, or have"]
    #[doc = " them in effect so they will be inherited at the time of object creation."]
    #[doc = ""]
    #[doc = " For example:"]
    #[doc = ""]
    #[doc = " exterm void MyStatusChangedFunc( SteamNetConnectionStatusChangedCallback_t *info );"]
    #[doc = " SteamNetworkingConfigValue_t opt; opt.SetPtr( k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged, MyStatusChangedFunc );"]
    #[doc = " SteamNetworkingIPAddr localAddress; localAddress.Clear();"]
    #[doc = " HSteamListenSocket hListenSock = SteamNetworkingSockets()->CreateListenSocketIP( localAddress, 1, &opt );"]
    #[doc = ""]
    #[doc = " When accepting an incoming connection, there is no atomic way to switch the"]
    #[doc = " callback.  However, if the connection is DOA, AcceptConnection() will fail, and"]
    #[doc = " you can fetch the state of the connection at that time."]
    #[doc = ""]
    #[doc = " If all connections and listen sockets can use the same callback, the simplest"]
    #[doc = " method is to set it globally before you create any listen sockets or connections."]
    k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged = 201,
    #[doc = " [global FnSteamNetAuthenticationStatusChanged] Callback that will be invoked"]
    #[doc = " when our auth state changes.  If you use this, install the callback before creating"]
    #[doc = " any connections or listen sockets, and don't change it."]
    #[doc = " See: ISteamNetworkingUtils::SetGlobalCallback_SteamNetAuthenticationStatusChanged"]
    k_ESteamNetworkingConfig_Callback_AuthStatusChanged = 202,
    #[doc = " [global FnSteamRelayNetworkStatusChanged] Callback that will be invoked"]
    #[doc = " when our auth state changes.  If you use this, install the callback before creating"]
    #[doc = " any connections or listen sockets, and don't change it."]
    #[doc = " See: ISteamNetworkingUtils::SetGlobalCallback_SteamRelayNetworkStatusChanged"]
    k_ESteamNetworkingConfig_Callback_RelayNetworkStatusChanged = 203,
    #[doc = " [global FnSteamNetworkingMessagesSessionRequest] Callback that will be invoked"]
    #[doc = " when a peer wants to initiate a SteamNetworkingMessagesSessionRequest."]
    #[doc = " See: ISteamNetworkingUtils::SetGlobalCallback_MessagesSessionRequest"]
    k_ESteamNetworkingConfig_Callback_MessagesSessionRequest = 204,
    #[doc = " [global FnSteamNetworkingMessagesSessionFailed] Callback that will be invoked"]
    #[doc = " when a session you have initiated, or accepted either fails to connect, or loses"]
    #[doc = " connection in some unexpected way."]
    #[doc = " See: ISteamNetworkingUtils::SetGlobalCallback_MessagesSessionFailed"]
    k_ESteamNetworkingConfig_Callback_MessagesSessionFailed = 205,
    #[doc = " [global FnSteamNetworkingSocketsCreateConnectionSignaling] Callback that will"]
    #[doc = " be invoked when we need to create a signaling object for a connection"]
    #[doc = " initiated locally.  See: ISteamNetworkingSockets::ConnectP2P,"]
    #[doc = " ISteamNetworkingMessages."]
    k_ESteamNetworkingConfig_Callback_CreateConnectionSignaling = 206,
    #[doc = " [global FnSteamNetworkingFakeIPResult] Callback that's invoked when"]
    #[doc = " a FakeIP allocation finishes.  See: ISteamNetworkingSockets::BeginAsyncRequestFakeIP,"]
    #[doc = " ISteamNetworkingUtils::SetGlobalCallback_FakeIPResult"]
    k_ESteamNetworkingConfig_Callback_FakeIPResult = 207,
    #[doc = " [connection string] Comma-separated list of STUN servers that can be used"]
    #[doc = " for NAT piercing.  If you set this to an empty string, NAT piercing will"]
    #[doc = " not be attempted.  Also if \"public\" candidates are not allowed for"]
    #[doc = " P2P_Transport_ICE_Enable, then this is ignored."]
    k_ESteamNetworkingConfig_P2P_STUN_ServerList = 103,
    #[doc = " [connection int32] What types of ICE candidates to share with the peer."]
    #[doc = " See k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_xxx values"]
    k_ESteamNetworkingConfig_P2P_Transport_ICE_Enable = 104,
    #[doc = " [connection int32] When selecting P2P transport, add various"]
    #[doc = " penalties to the scores for selected transports.  (Route selection"]
    #[doc = " scores are on a scale of milliseconds.  The score begins with the"]
    #[doc = " route ping time and is then adjusted.)"]
    k_ESteamNetworkingConfig_P2P_Transport_ICE_Penalty = 105,
    #[doc = " [connection int32] When selecting P2P transport, add various"]
    #[doc = " penalties to the scores for selected transports.  (Route selection"]
    #[doc = " scores are on a scale of milliseconds.  The score begins with the"]
    #[doc = " route ping time and is then adjusted.)"]
    k_ESteamNetworkingConfig_P2P_Transport_SDR_Penalty = 106,
    #[doc = " [connection int32] When selecting P2P transport, add various"]
    #[doc = " penalties to the scores for selected transports.  (Route selection"]
    #[doc = " scores are on a scale of milliseconds.  The score begins with the"]
    #[doc = " route ping time and is then adjusted.)"]
    k_ESteamNetworkingConfig_P2P_TURN_ServerList = 107,
    #[doc = " [connection int32] When selecting P2P transport, add various"]
    #[doc = " penalties to the scores for selected transports.  (Route selection"]
    #[doc = " scores are on a scale of milliseconds.  The score begins with the"]
    #[doc = " route ping time and is then adjusted.)"]
    k_ESteamNetworkingConfig_P2P_TURN_UserList = 108,
    #[doc = " [connection int32] When selecting P2P transport, add various"]
    #[doc = " penalties to the scores for selected transports.  (Route selection"]
    #[doc = " scores are on a scale of milliseconds.  The score begins with the"]
    #[doc = " route ping time and is then adjusted.)"]
    k_ESteamNetworkingConfig_P2P_TURN_PassList = 109,
    #[doc = " [connection int32] When selecting P2P transport, add various"]
    #[doc = " penalties to the scores for selected transports.  (Route selection"]
    #[doc = " scores are on a scale of milliseconds.  The score begins with the"]
    #[doc = " route ping time and is then adjusted.)"]
    k_ESteamNetworkingConfig_P2P_Transport_ICE_Implementation = 110,
    #[doc = " [int32 global] If the first N pings to a port all fail, mark that port as unavailable for"]
    #[doc = " a while, and try a different one.  Some ISPs and routers may drop the first"]
    #[doc = " packet, so setting this to 1 may greatly disrupt communications."]
    k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFailInitial = 19,
    #[doc = " [int32 global] If N consecutive pings to a port fail, after having received successful"]
    #[doc = " communication, mark that port as unavailable for a while, and try a"]
    #[doc = " different one."]
    k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFail = 20,
    #[doc = " [int32 global] Minimum number of lifetime pings we need to send, before we think our estimate"]
    #[doc = " is solid.  The first ping to each cluster is very often delayed because of NAT,"]
    #[doc = " routers not having the best route, etc.  Until we've sent a sufficient number"]
    #[doc = " of pings, our estimate is often inaccurate.  Keep pinging until we get this"]
    #[doc = " many pings."]
    k_ESteamNetworkingConfig_SDRClient_MinPingsBeforePingAccurate = 21,
    #[doc = " [int32 global] Set all steam datagram traffic to originate from the same"]
    #[doc = " local port. By default, we open up a new UDP socket (on a different local"]
    #[doc = " port) for each relay.  This is slightly less optimal, but it works around"]
    #[doc = " some routers that don't implement NAT properly.  If you have intermittent"]
    #[doc = " problems talking to relays that might be NAT related, try toggling"]
    #[doc = " this flag"]
    k_ESteamNetworkingConfig_SDRClient_SingleSocket = 22,
    #[doc = " [global string] Code of relay cluster to force use.  If not empty, we will"]
    #[doc = " only use relays in that cluster.  E.g. 'iad'"]
    k_ESteamNetworkingConfig_SDRClient_ForceRelayCluster = 29,
    #[doc = " [connection string] For debugging, generate our own (unsigned) ticket, using"]
    #[doc = " the specified  gameserver address.  Router must be configured to accept unsigned"]
    #[doc = " tickets."]
    k_ESteamNetworkingConfig_SDRClient_DebugTicketAddress = 30,
    #[doc = " [global string] For debugging.  Override list of relays from the config with"]
    #[doc = " this set (maybe just one).  Comma-separated list."]
    k_ESteamNetworkingConfig_SDRClient_ForceProxyAddr = 31,
    #[doc = " [global string] For debugging.  Force ping times to clusters to be the specified"]
    #[doc = " values.  A comma separated list of <cluster>=<ms> values.  E.g. \"sto=32,iad=100\""]
    #[doc = ""]
    #[doc = " This is a dev configuration value, you probably should not let users modify it"]
    #[doc = " in production."]
    k_ESteamNetworkingConfig_SDRClient_FakeClusterPing = 36,
    #[doc = " [global string] For debugging.  Force ping times to clusters to be the specified"]
    #[doc = " values.  A comma separated list of <cluster>=<ms> values.  E.g. \"sto=32,iad=100\""]
    #[doc = ""]
    #[doc = " This is a dev configuration value, you probably should not let users modify it"]
    #[doc = " in production."]
    k_ESteamNetworkingConfig_LogLevel_AckRTT = 13,
    #[doc = " [global string] For debugging.  Force ping times to clusters to be the specified"]
    #[doc = " values.  A comma separated list of <cluster>=<ms> values.  E.g. \"sto=32,iad=100\""]
    #[doc = ""]
    #[doc = " This is a dev configuration value, you probably should not let users modify it"]
    #[doc = " in production."]
    k_ESteamNetworkingConfig_LogLevel_PacketDecode = 14,
    #[doc = " [global string] For debugging.  Force ping times to clusters to be the specified"]
    #[doc = " values.  A comma separated list of <cluster>=<ms> values.  E.g. \"sto=32,iad=100\""]
    #[doc = ""]
    #[doc = " This is a dev configuration value, you probably should not let users modify it"]
    #[doc = " in production."]
    k_ESteamNetworkingConfig_LogLevel_Message = 15,
    #[doc = " [global string] For debugging.  Force ping times to clusters to be the specified"]
    #[doc = " values.  A comma separated list of <cluster>=<ms> values.  E.g. \"sto=32,iad=100\""]
    #[doc = ""]
    #[doc = " This is a dev configuration value, you probably should not let users modify it"]
    #[doc = " in production."]
    k_ESteamNetworkingConfig_LogLevel_PacketGaps = 16,
    #[doc = " [global string] For debugging.  Force ping times to clusters to be the specified"]
    #[doc = " values.  A comma separated list of <cluster>=<ms> values.  E.g. \"sto=32,iad=100\""]
    #[doc = ""]
    #[doc = " This is a dev configuration value, you probably should not let users modify it"]
    #[doc = " in production."]
    k_ESteamNetworkingConfig_LogLevel_P2PRendezvous = 17,
    #[doc = " [global string] For debugging.  Force ping times to clusters to be the specified"]
    #[doc = " values.  A comma separated list of <cluster>=<ms> values.  E.g. \"sto=32,iad=100\""]
    #[doc = ""]
    #[doc = " This is a dev configuration value, you probably should not let users modify it"]
    #[doc = " in production."]
    k_ESteamNetworkingConfig_LogLevel_SDRRelayPings = 18,
    #[doc = " [global string] For debugging.  Force ping times to clusters to be the specified"]
    #[doc = " values.  A comma separated list of <cluster>=<ms> values.  E.g. \"sto=32,iad=100\""]
    #[doc = ""]
    #[doc = " This is a dev configuration value, you probably should not let users modify it"]
    #[doc = " in production."]
    k_ESteamNetworkingConfig_DELETED_EnumerateDevVars = 35,
    #[doc = " [global string] For debugging.  Force ping times to clusters to be the specified"]
    #[doc = " values.  A comma separated list of <cluster>=<ms> values.  E.g. \"sto=32,iad=100\""]
    #[doc = ""]
    #[doc = " This is a dev configuration value, you probably should not let users modify it"]
    #[doc = " in production."]
    k_ESteamNetworkingConfigValue__Force32Bit = 2147483647,
}
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Default: ::std::os::raw::c_int = -1;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Disable: ::std::os::raw::c_int = 0;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Relay: ::std::os::raw::c_int = 1;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Private: ::std::os::raw::c_int = 2;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Public: ::std::os::raw::c_int = 4;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_All: ::std::os::raw::c_int = 2147483647;
#[doc = " In a few places we need to set configuration options on listen sockets and connections, and"]
#[doc = " have them take effect *before* the listen socket or connection really starts doing anything."]
#[doc = " Creating the object and then setting the options \"immediately\" after creation doesn't work"]
#[doc = " completely, because network packets could be received between the time the object is created and"]
#[doc = " when the options are applied.  To set options at creation time in a reliable way, they must be"]
#[doc = " passed to the creation function.  This structure is used to pass those options."]
#[doc = ""]
#[doc = " For the meaning of these fields, see ISteamNetworkingUtils::SetConfigValue.  Basically"]
#[doc = " when the object is created, we just iterate over the list of options and call"]
#[doc = " ISteamNetworkingUtils::SetConfigValueStruct, where the scope arguments are supplied by the"]
#[doc = " object being created."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SteamNetworkingConfigValue_t {
    #[doc = " Which option is being set"]
    pub m_eValue: ESteamNetworkingConfigValue,
    #[doc = " Which field below did you fill in?"]
    pub m_eDataType: ESteamNetworkingConfigDataType,
    pub m_val: SteamNetworkingConfigValue_t__bindgen_ty_1,
}
#[doc = " Option value"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SteamNetworkingConfigValue_t__bindgen_ty_1 {
    pub m_int32: i32,
    pub m_int64: i64,
    pub m_float: f32,
    pub m_string: *const ::std::os::raw::c_char,
    pub m_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SteamNetworkingConfigValue_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingConfigValue_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingConfigValue_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1)
        )
    );
    fn test_field_m_int32() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetworkingConfigValue_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_int32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1),
                "::",
                stringify!(m_int32)
            )
        );
    }
    test_field_m_int32();
    fn test_field_m_int64() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetworkingConfigValue_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_int64) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1),
                "::",
                stringify!(m_int64)
            )
        );
    }
    test_field_m_int64();
    fn test_field_m_float() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetworkingConfigValue_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_float) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1),
                "::",
                stringify!(m_float)
            )
        );
    }
    test_field_m_float();
    fn test_field_m_string() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetworkingConfigValue_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_string) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1),
                "::",
                stringify!(m_string)
            )
        );
    }
    test_field_m_string();
    fn test_field_m_ptr() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetworkingConfigValue_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_ptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1),
                "::",
                stringify!(m_ptr)
            )
        );
    }
    test_field_m_ptr();
}
impl Default for SteamNetworkingConfigValue_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_SteamNetworkingConfigValue_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingConfigValue_t>(),
        16usize,
        concat!("Size of: ", stringify!(SteamNetworkingConfigValue_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingConfigValue_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SteamNetworkingConfigValue_t))
    );
    fn test_field_m_eValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingConfigValue_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_eValue) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingConfigValue_t),
                "::",
                stringify!(m_eValue)
            )
        );
    }
    test_field_m_eValue();
    fn test_field_m_eDataType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingConfigValue_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_eDataType) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingConfigValue_t),
                "::",
                stringify!(m_eDataType)
            )
        );
    }
    test_field_m_eDataType();
    fn test_field_m_val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingConfigValue_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_val) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingConfigValue_t),
                "::",
                stringify!(m_val)
            )
        );
    }
    test_field_m_val();
}
impl Default for SteamNetworkingConfigValue_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[doc = " Return value of ISteamNetworkintgUtils::GetConfigValue"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum ESteamNetworkingGetConfigValueResult {
    k_ESteamNetworkingGetConfigValue_BadValue = -1,
    k_ESteamNetworkingGetConfigValue_BadScopeObj = -2,
    k_ESteamNetworkingGetConfigValue_BufferTooSmall = -3,
    k_ESteamNetworkingGetConfigValue_OK = 1,
    k_ESteamNetworkingGetConfigValue_OKInherited = 2,
    k_ESteamNetworkingGetConfigValueResult__Force32Bit = 2147483647,
}
#[repr(u32)]
#[doc = " Detail level for diagnostic output callback."]
#[doc = " See ISteamNetworkingUtils::SetDebugOutputFunction"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum ESteamNetworkingSocketsDebugOutputType {
    k_ESteamNetworkingSocketsDebugOutputType_None = 0,
    k_ESteamNetworkingSocketsDebugOutputType_Bug = 1,
    k_ESteamNetworkingSocketsDebugOutputType_Error = 2,
    k_ESteamNetworkingSocketsDebugOutputType_Important = 3,
    k_ESteamNetworkingSocketsDebugOutputType_Warning = 4,
    k_ESteamNetworkingSocketsDebugOutputType_Msg = 5,
    k_ESteamNetworkingSocketsDebugOutputType_Verbose = 6,
    k_ESteamNetworkingSocketsDebugOutputType_Debug = 7,
    k_ESteamNetworkingSocketsDebugOutputType_Everything = 8,
    k_ESteamNetworkingSocketsDebugOutputType__Force32Bit = 2147483647,
}
#[doc = " Setup callback for debug output, and the desired verbosity you want."]
pub type FSteamNetworkingSocketsDebugOutput = ::std::option::Option<
    unsafe extern "C" fn(
        nType: ESteamNetworkingSocketsDebugOutputType,
        pszMsg: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " The POPID \"dev\" is used in non-production environments for testing."]
pub const k_SteamDatagramPOPID_dev: SteamNetworkingPOPID = 6579574;
#[doc = " Utility class for printing a SteamNetworkingPOPID."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct SteamNetworkingPOPIDRender {
    pub buf: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkingPOPIDRender() {
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingPOPIDRender>(),
        8usize,
        concat!("Size of: ", stringify!(SteamNetworkingPOPIDRender))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingPOPIDRender>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkingPOPIDRender))
    );
    fn test_field_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingPOPIDRender>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingPOPIDRender),
                "::",
                stringify!(buf)
            )
        );
    }
    test_field_buf();
}
#[doc = " A message that has been received."]
pub type ISteamNetworkingMessage = SteamNetworkingMessage_t;
pub type SteamDatagramErrMsg = SteamNetworkingErrMsg;
pub const k_iSteamNetworkingSocketsCallbacks: _bindgen_ty_1 =
    _bindgen_ty_1::k_iSteamNetworkingSocketsCallbacks;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _bindgen_ty_1 {
    k_iSteamNetworkingSocketsCallbacks = 1220,
}
pub const k_iSteamNetworkingMessagesCallbacks: _bindgen_ty_2 =
    _bindgen_ty_2::k_iSteamNetworkingMessagesCallbacks;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _bindgen_ty_2 {
    k_iSteamNetworkingMessagesCallbacks = 1250,
}
pub const k_iSteamNetworkingUtilsCallbacks: _bindgen_ty_3 =
    _bindgen_ty_3::k_iSteamNetworkingUtilsCallbacks;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _bindgen_ty_3 {
    k_iSteamNetworkingUtilsCallbacks = 1280,
}
pub type HSteamPipe = int32;
pub type HSteamUser = int32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamNetworkingConnectionSignaling {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamNetworkingSignalingRecvContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamNetworkingFakeUDPPort {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ISteamNetworkingSockets__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Lower level networking API."]
#[doc = ""]
#[doc = " - Connection-oriented API (like TCP, not UDP).  When sending and receiving"]
#[doc = "   messages, a connection handle is used.  (For a UDP-style interface, where"]
#[doc = "   the peer is identified by their address with each send/recv call, see"]
#[doc = "   ISteamNetworkingMessages.)  The typical pattern is for a \"server\" to \"listen\""]
#[doc = "   on a \"listen socket.\"  A \"client\" will \"connect\" to the server, and the"]
#[doc = "   server will \"accept\" the connection.  If you have a symmetric situation"]
#[doc = "   where either peer may initiate the connection and server/client roles are"]
#[doc = "   not clearly defined, check out k_ESteamNetworkingConfig_SymmetricConnect."]
#[doc = " - But unlike TCP, it's message-oriented, not stream-oriented."]
#[doc = " - Mix of reliable and unreliable messages"]
#[doc = " - Fragmentation and reassembly"]
#[doc = " - Supports connectivity over plain UDP"]
#[doc = " - Also supports SDR (\"Steam Datagram Relay\") connections, which are"]
#[doc = "   addressed by the identity of the peer.  There is a \"P2P\" use case and"]
#[doc = "   a \"hosted dedicated server\" use case."]
#[doc = ""]
#[doc = " Note that neither of the terms \"connection\" nor \"socket\" necessarily correspond"]
#[doc = " one-to-one with an underlying UDP socket.  An attempt has been made to"]
#[doc = " keep the semantics as similar to the standard socket model when appropriate,"]
#[doc = " but some deviations do exist."]
#[doc = ""]
#[doc = " See also: ISteamNetworkingMessages, the UDP-style interface.  This API might be"]
#[doc = " easier to use, especially when porting existing UDP code."]
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ISteamNetworkingSockets {
    pub vtable_: *const ISteamNetworkingSockets__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamNetworkingSockets() {
    assert_eq!(
        ::std::mem::size_of::<ISteamNetworkingSockets>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamNetworkingSockets))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamNetworkingSockets>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamNetworkingSockets))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23ISteamNetworkingSocketsD1Ev"]
    pub fn ISteamNetworkingSockets_ISteamNetworkingSockets_destructor(
        this: *mut ISteamNetworkingSockets,
    );
}
impl Default for ISteamNetworkingSockets {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ISteamNetworkingSockets {
    #[inline]
    pub unsafe fn destruct(&mut self) {
        ISteamNetworkingSockets_ISteamNetworkingSockets_destructor(self)
    }
}
extern "C" {
    pub fn SteamNetworkingSockets_LibV12() -> *mut ISteamNetworkingSockets;
}
extern "C" {
    pub fn SteamGameServerNetworkingSockets_LibV12() -> *mut ISteamNetworkingSockets;
}
#[doc = " This callback is posted whenever a connection is created, destroyed, or changes state."]
#[doc = " The m_info field will contain a complete description of the connection at the time the"]
#[doc = " change occurred and the callback was posted.  In particular, m_eState will have the"]
#[doc = " new connection state."]
#[doc = ""]
#[doc = " You will usually need to listen for this callback to know when:"]
#[doc = " - A new connection arrives on a listen socket."]
#[doc = "   m_info.m_hListenSocket will be set, m_eOldState = k_ESteamNetworkingConnectionState_None,"]
#[doc = "   and m_info.m_eState = k_ESteamNetworkingConnectionState_Connecting."]
#[doc = "   See ISteamNetworkigSockets::AcceptConnection."]
#[doc = " - A connection you initiated has been accepted by the remote host."]
#[doc = "   m_eOldState = k_ESteamNetworkingConnectionState_Connecting, and"]
#[doc = "   m_info.m_eState = k_ESteamNetworkingConnectionState_Connected."]
#[doc = "   Some connections might transition to k_ESteamNetworkingConnectionState_FindingRoute first."]
#[doc = " - A connection has been actively rejected or closed by the remote host."]
#[doc = "   m_eOldState = k_ESteamNetworkingConnectionState_Connecting or k_ESteamNetworkingConnectionState_Connected,"]
#[doc = "   and m_info.m_eState = k_ESteamNetworkingConnectionState_ClosedByPeer.  m_info.m_eEndReason"]
#[doc = "   and m_info.m_szEndDebug will have for more details."]
#[doc = "   NOTE: upon receiving this callback, you must still destroy the connection using"]
#[doc = "   ISteamNetworkingSockets::CloseConnection to free up local resources.  (The details"]
#[doc = "   passed to the function are not used in this case, since the connection is already closed.)"]
#[doc = " - A problem was detected with the connection, and it has been closed by the local host."]
#[doc = "   The most common failure is timeout, but other configuration or authentication failures"]
#[doc = "   can cause this.  m_eOldState = k_ESteamNetworkingConnectionState_Connecting or"]
#[doc = "   k_ESteamNetworkingConnectionState_Connected, and m_info.m_eState = k_ESteamNetworkingConnectionState_ProblemDetectedLocally."]
#[doc = "   m_info.m_eEndReason and m_info.m_szEndDebug will have for more details."]
#[doc = "   NOTE: upon receiving this callback, you must still destroy the connection using"]
#[doc = "   ISteamNetworkingSockets::CloseConnection to free up local resources.  (The details"]
#[doc = "   passed to the function are not used in this case, since the connection is already closed.)"]
#[doc = ""]
#[doc = " Remember that callbacks are posted to a queue, and networking connections can"]
#[doc = " change at any time.  It is possible that the connection has already changed"]
#[doc = " state by the time you process this callback."]
#[doc = ""]
#[doc = " Also note that callbacks will be posted when connections are created and destroyed by your own API calls."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SteamNetConnectionStatusChangedCallback_t {
    #[doc = " Connection handle"]
    pub m_hConn: HSteamNetConnection,
    #[doc = " Full connection info"]
    pub m_info: SteamNetConnectionInfo_t,
    #[doc = " Previous state.  (Current state is in m_info.m_eState)"]
    pub m_eOldState: ESteamNetworkingConnectionState,
}
pub const SteamNetConnectionStatusChangedCallback_t_k_iCallback:
    SteamNetConnectionStatusChangedCallback_t__bindgen_ty_1 =
    SteamNetConnectionStatusChangedCallback_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum SteamNetConnectionStatusChangedCallback_t__bindgen_ty_1 {
    k_iCallback = 1221,
}
#[test]
fn bindgen_test_layout_SteamNetConnectionStatusChangedCallback_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamNetConnectionStatusChangedCallback_t>(),
        704usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetConnectionStatusChangedCallback_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetConnectionStatusChangedCallback_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetConnectionStatusChangedCallback_t)
        )
    );
    fn test_field_m_hConn() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionStatusChangedCallback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_hConn) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionStatusChangedCallback_t),
                "::",
                stringify!(m_hConn)
            )
        );
    }
    test_field_m_hConn();
    fn test_field_m_info() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionStatusChangedCallback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_info) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionStatusChangedCallback_t),
                "::",
                stringify!(m_info)
            )
        );
    }
    test_field_m_info();
    fn test_field_m_eOldState() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<SteamNetConnectionStatusChangedCallback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_eOldState) as usize - ptr as usize
            },
            700usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetConnectionStatusChangedCallback_t),
                "::",
                stringify!(m_eOldState)
            )
        );
    }
    test_field_m_eOldState();
}
impl Default for SteamNetConnectionStatusChangedCallback_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A struct used to describe our readiness to participate in authenticated,"]
#[doc = " encrypted communication.  In order to do this we need:"]
#[doc = ""]
#[doc = " - The list of trusted CA certificates that might be relevant for this"]
#[doc = "   app."]
#[doc = " - A valid certificate issued by a CA."]
#[doc = ""]
#[doc = " This callback is posted whenever the state of our readiness changes."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct SteamNetAuthenticationStatus_t {
    #[doc = " Status"]
    pub m_eAvail: ESteamNetworkingAvailability,
    #[doc = " Non-localized English language status.  For diagnostic/debugging"]
    #[doc = " purposes only."]
    pub m_debugMsg: [::std::os::raw::c_char; 256usize],
}
pub const SteamNetAuthenticationStatus_t_k_iCallback: SteamNetAuthenticationStatus_t__bindgen_ty_1 =
    SteamNetAuthenticationStatus_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum SteamNetAuthenticationStatus_t__bindgen_ty_1 {
    k_iCallback = 1222,
}
#[test]
fn bindgen_test_layout_SteamNetAuthenticationStatus_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamNetAuthenticationStatus_t>(),
        260usize,
        concat!("Size of: ", stringify!(SteamNetAuthenticationStatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetAuthenticationStatus_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamNetAuthenticationStatus_t))
    );
    fn test_field_m_eAvail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetAuthenticationStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_eAvail) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetAuthenticationStatus_t),
                "::",
                stringify!(m_eAvail)
            )
        );
    }
    test_field_m_eAvail();
    fn test_field_m_debugMsg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetAuthenticationStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_debugMsg) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetAuthenticationStatus_t),
                "::",
                stringify!(m_debugMsg)
            )
        );
    }
    test_field_m_debugMsg();
}
impl Default for SteamNetAuthenticationStatus_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ISteamNetworkingUtils__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Misc networking utilities for checking the local networking environment"]
#[doc = " and estimating pings."]
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ISteamNetworkingUtils {
    pub vtable_: *const ISteamNetworkingUtils__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamNetworkingUtils() {
    assert_eq!(
        ::std::mem::size_of::<ISteamNetworkingUtils>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamNetworkingUtils))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamNetworkingUtils>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamNetworkingUtils))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21ISteamNetworkingUtils25SetGlobalConfigValueInt32E27ESteamNetworkingConfigValuei"]
    pub fn ISteamNetworkingUtils_SetGlobalConfigValueInt32(
        this: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        val: int32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN21ISteamNetworkingUtils25SetGlobalConfigValueFloatE27ESteamNetworkingConfigValuef"]
    pub fn ISteamNetworkingUtils_SetGlobalConfigValueFloat(
        this: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        val: f32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN21ISteamNetworkingUtils26SetGlobalConfigValueStringE27ESteamNetworkingConfigValuePKc"]
    pub fn ISteamNetworkingUtils_SetGlobalConfigValueString(
        this: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        val: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN21ISteamNetworkingUtils23SetGlobalConfigValuePtrE27ESteamNetworkingConfigValuePv"]
    pub fn ISteamNetworkingUtils_SetGlobalConfigValuePtr(
        this: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        val: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN21ISteamNetworkingUtils29SetConnectionConfigValueInt32Ej27ESteamNetworkingConfigValuei"]
    pub fn ISteamNetworkingUtils_SetConnectionConfigValueInt32(
        this: *mut ISteamNetworkingUtils,
        hConn: HSteamNetConnection,
        eValue: ESteamNetworkingConfigValue,
        val: int32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN21ISteamNetworkingUtils29SetConnectionConfigValueFloatEj27ESteamNetworkingConfigValuef"]
    pub fn ISteamNetworkingUtils_SetConnectionConfigValueFloat(
        this: *mut ISteamNetworkingUtils,
        hConn: HSteamNetConnection,
        eValue: ESteamNetworkingConfigValue,
        val: f32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN21ISteamNetworkingUtils30SetConnectionConfigValueStringEj27ESteamNetworkingConfigValuePKc"]
    pub fn ISteamNetworkingUtils_SetConnectionConfigValueString(
        this: *mut ISteamNetworkingUtils,
        hConn: HSteamNetConnection,
        eValue: ESteamNetworkingConfigValue,
        val: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN21ISteamNetworkingUtils49SetGlobalCallback_SteamNetConnectionStatusChangedEPFvP41SteamNetConnectionStatusChangedCallback_tE"]
    pub fn ISteamNetworkingUtils_SetGlobalCallback_SteamNetConnectionStatusChanged(
        this: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetConnectionStatusChanged,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN21ISteamNetworkingUtils53SetGlobalCallback_SteamNetAuthenticationStatusChangedEPFvP30SteamNetAuthenticationStatus_tE"]
    pub fn ISteamNetworkingUtils_SetGlobalCallback_SteamNetAuthenticationStatusChanged(
        this: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetAuthenticationStatusChanged,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN21ISteamNetworkingUtils48SetGlobalCallback_SteamRelayNetworkStatusChangedEPFvP25SteamRelayNetworkStatus_tE"]
    pub fn ISteamNetworkingUtils_SetGlobalCallback_SteamRelayNetworkStatusChanged(
        this: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamRelayNetworkStatusChanged,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN21ISteamNetworkingUtils30SetGlobalCallback_FakeIPResultEPFvP29SteamNetworkingFakeIPResult_tE"]
    pub fn ISteamNetworkingUtils_SetGlobalCallback_FakeIPResult(
        this: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetworkingFakeIPResult,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN21ISteamNetworkingUtils40SetGlobalCallback_MessagesSessionRequestEPFvP39SteamNetworkingMessagesSessionRequest_tE"]
    pub fn ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionRequest(
        this: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetworkingMessagesSessionRequest,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN21ISteamNetworkingUtils39SetGlobalCallback_MessagesSessionFailedEPFvP38SteamNetworkingMessagesSessionFailed_tE"]
    pub fn ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionFailed(
        this: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetworkingMessagesSessionFailed,
    ) -> bool;
}
extern "C" {
    #[doc = " Set a configuration value, using a struct to pass the value."]
    #[doc = " (This is just a convenience shortcut; see below for the implementation and"]
    #[doc = " a little insight into how SteamNetworkingConfigValue_t is used when"]
    #[doc = " setting config options during listen socket and connection creation.)"]
    #[link_name = "\u{1}_ZN21ISteamNetworkingUtils20SetConfigValueStructERK28SteamNetworkingConfigValue_t27ESteamNetworkingConfigScopel"]
    pub fn ISteamNetworkingUtils_SetConfigValueStruct(
        this: *mut ISteamNetworkingUtils,
        opt: *const SteamNetworkingConfigValue_t,
        eScopeType: ESteamNetworkingConfigScope,
        scopeObj: isize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN21ISteamNetworkingUtilsD1Ev"]
    pub fn ISteamNetworkingUtils_ISteamNetworkingUtils_destructor(this: *mut ISteamNetworkingUtils);
}
impl Default for ISteamNetworkingUtils {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ISteamNetworkingUtils {
    #[inline]
    pub unsafe fn SetGlobalConfigValueInt32(
        &mut self,
        eValue: ESteamNetworkingConfigValue,
        val: int32,
    ) -> bool {
        ISteamNetworkingUtils_SetGlobalConfigValueInt32(self, eValue, val)
    }
    #[inline]
    pub unsafe fn SetGlobalConfigValueFloat(
        &mut self,
        eValue: ESteamNetworkingConfigValue,
        val: f32,
    ) -> bool {
        ISteamNetworkingUtils_SetGlobalConfigValueFloat(self, eValue, val)
    }
    #[inline]
    pub unsafe fn SetGlobalConfigValueString(
        &mut self,
        eValue: ESteamNetworkingConfigValue,
        val: *const ::std::os::raw::c_char,
    ) -> bool {
        ISteamNetworkingUtils_SetGlobalConfigValueString(self, eValue, val)
    }
    #[inline]
    pub unsafe fn SetGlobalConfigValuePtr(
        &mut self,
        eValue: ESteamNetworkingConfigValue,
        val: *mut ::std::os::raw::c_void,
    ) -> bool {
        ISteamNetworkingUtils_SetGlobalConfigValuePtr(self, eValue, val)
    }
    #[inline]
    pub unsafe fn SetConnectionConfigValueInt32(
        &mut self,
        hConn: HSteamNetConnection,
        eValue: ESteamNetworkingConfigValue,
        val: int32,
    ) -> bool {
        ISteamNetworkingUtils_SetConnectionConfigValueInt32(self, hConn, eValue, val)
    }
    #[inline]
    pub unsafe fn SetConnectionConfigValueFloat(
        &mut self,
        hConn: HSteamNetConnection,
        eValue: ESteamNetworkingConfigValue,
        val: f32,
    ) -> bool {
        ISteamNetworkingUtils_SetConnectionConfigValueFloat(self, hConn, eValue, val)
    }
    #[inline]
    pub unsafe fn SetConnectionConfigValueString(
        &mut self,
        hConn: HSteamNetConnection,
        eValue: ESteamNetworkingConfigValue,
        val: *const ::std::os::raw::c_char,
    ) -> bool {
        ISteamNetworkingUtils_SetConnectionConfigValueString(self, hConn, eValue, val)
    }
    #[inline]
    pub unsafe fn SetGlobalCallback_SteamNetConnectionStatusChanged(
        &mut self,
        fnCallback: FnSteamNetConnectionStatusChanged,
    ) -> bool {
        ISteamNetworkingUtils_SetGlobalCallback_SteamNetConnectionStatusChanged(self, fnCallback)
    }
    #[inline]
    pub unsafe fn SetGlobalCallback_SteamNetAuthenticationStatusChanged(
        &mut self,
        fnCallback: FnSteamNetAuthenticationStatusChanged,
    ) -> bool {
        ISteamNetworkingUtils_SetGlobalCallback_SteamNetAuthenticationStatusChanged(
            self, fnCallback,
        )
    }
    #[inline]
    pub unsafe fn SetGlobalCallback_SteamRelayNetworkStatusChanged(
        &mut self,
        fnCallback: FnSteamRelayNetworkStatusChanged,
    ) -> bool {
        ISteamNetworkingUtils_SetGlobalCallback_SteamRelayNetworkStatusChanged(self, fnCallback)
    }
    #[inline]
    pub unsafe fn SetGlobalCallback_FakeIPResult(
        &mut self,
        fnCallback: FnSteamNetworkingFakeIPResult,
    ) -> bool {
        ISteamNetworkingUtils_SetGlobalCallback_FakeIPResult(self, fnCallback)
    }
    #[inline]
    pub unsafe fn SetGlobalCallback_MessagesSessionRequest(
        &mut self,
        fnCallback: FnSteamNetworkingMessagesSessionRequest,
    ) -> bool {
        ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionRequest(self, fnCallback)
    }
    #[inline]
    pub unsafe fn SetGlobalCallback_MessagesSessionFailed(
        &mut self,
        fnCallback: FnSteamNetworkingMessagesSessionFailed,
    ) -> bool {
        ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionFailed(self, fnCallback)
    }
    #[inline]
    pub unsafe fn SetConfigValueStruct(
        &mut self,
        opt: *const SteamNetworkingConfigValue_t,
        eScopeType: ESteamNetworkingConfigScope,
        scopeObj: isize,
    ) -> bool {
        ISteamNetworkingUtils_SetConfigValueStruct(self, opt, eScopeType, scopeObj)
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        ISteamNetworkingUtils_ISteamNetworkingUtils_destructor(self)
    }
}
extern "C" {
    pub fn SteamNetworkingUtils_LibV4() -> *mut ISteamNetworkingUtils;
}
#[doc = " A struct used to describe our readiness to use the relay network."]
#[doc = " To do this we first need to fetch the network configuration,"]
#[doc = " which describes what POPs are available."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct SteamRelayNetworkStatus_t {
    #[doc = " Summary status.  When this is \"current\", initialization has"]
    #[doc = " completed.  Anything else means you are not ready yet, or"]
    #[doc = " there is a significant problem."]
    pub m_eAvail: ESteamNetworkingAvailability,
    #[doc = " Nonzero if latency measurement is in progress (or pending,"]
    #[doc = " awaiting a prerequisite)."]
    pub m_bPingMeasurementInProgress: ::std::os::raw::c_int,
    #[doc = " Status obtaining the network config.  This is a prerequisite"]
    #[doc = " for relay network access."]
    #[doc = ""]
    #[doc = " Failure to obtain the network config almost always indicates"]
    #[doc = " a problem with the local internet connection."]
    pub m_eAvailNetworkConfig: ESteamNetworkingAvailability,
    #[doc = " Current ability to communicate with ANY relay.  Note that"]
    #[doc = " the complete failure to communicate with any relays almost"]
    #[doc = " always indicates a problem with the local Internet connection."]
    #[doc = " (However, just because you can reach a single relay doesn't"]
    #[doc = " mean that the local connection is in perfect health.)"]
    pub m_eAvailAnyRelay: ESteamNetworkingAvailability,
    #[doc = " Non-localized English language status.  For diagnostic/debugging"]
    #[doc = " purposes only."]
    pub m_debugMsg: [::std::os::raw::c_char; 256usize],
}
pub const SteamRelayNetworkStatus_t_k_iCallback: SteamRelayNetworkStatus_t__bindgen_ty_1 =
    SteamRelayNetworkStatus_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum SteamRelayNetworkStatus_t__bindgen_ty_1 {
    k_iCallback = 1281,
}
#[test]
fn bindgen_test_layout_SteamRelayNetworkStatus_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamRelayNetworkStatus_t>(),
        272usize,
        concat!("Size of: ", stringify!(SteamRelayNetworkStatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamRelayNetworkStatus_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamRelayNetworkStatus_t))
    );
    fn test_field_m_eAvail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamRelayNetworkStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_eAvail) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamRelayNetworkStatus_t),
                "::",
                stringify!(m_eAvail)
            )
        );
    }
    test_field_m_eAvail();
    fn test_field_m_bPingMeasurementInProgress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamRelayNetworkStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_bPingMeasurementInProgress) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamRelayNetworkStatus_t),
                "::",
                stringify!(m_bPingMeasurementInProgress)
            )
        );
    }
    test_field_m_bPingMeasurementInProgress();
    fn test_field_m_eAvailNetworkConfig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamRelayNetworkStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_eAvailNetworkConfig) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamRelayNetworkStatus_t),
                "::",
                stringify!(m_eAvailNetworkConfig)
            )
        );
    }
    test_field_m_eAvailNetworkConfig();
    fn test_field_m_eAvailAnyRelay() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamRelayNetworkStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_eAvailAnyRelay) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamRelayNetworkStatus_t),
                "::",
                stringify!(m_eAvailAnyRelay)
            )
        );
    }
    test_field_m_eAvailAnyRelay();
    fn test_field_m_debugMsg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamRelayNetworkStatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_debugMsg) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamRelayNetworkStatus_t),
                "::",
                stringify!(m_debugMsg)
            )
        );
    }
    test_field_m_debugMsg();
}
impl Default for SteamRelayNetworkStatus_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Utility class for printing a SteamNetworkingIdentity."]
#[doc = " E.g. printf( \"Identity is '%s'\\n\", SteamNetworkingIdentityRender( identity ).c_str() );"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct SteamNetworkingIdentityRender {
    pub buf: [::std::os::raw::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkingIdentityRender() {
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIdentityRender>(),
        128usize,
        concat!("Size of: ", stringify!(SteamNetworkingIdentityRender))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIdentityRender>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkingIdentityRender))
    );
    fn test_field_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingIdentityRender>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingIdentityRender),
                "::",
                stringify!(buf)
            )
        );
    }
    test_field_buf();
}
impl Default for SteamNetworkingIdentityRender {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Utility class for printing a SteamNetworkingIPAddrRender."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct SteamNetworkingIPAddrRender {
    pub buf: [::std::os::raw::c_char; 48usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkingIPAddrRender() {
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIPAddrRender>(),
        48usize,
        concat!("Size of: ", stringify!(SteamNetworkingIPAddrRender))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIPAddrRender>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkingIPAddrRender))
    );
    fn test_field_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SteamNetworkingIPAddrRender>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SteamNetworkingIPAddrRender),
                "::",
                stringify!(buf)
            )
        );
    }
    test_field_buf();
}
impl Default for SteamNetworkingIPAddrRender {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn SteamNetworkingIPAddr_ToString(
        pAddr: *const SteamNetworkingIPAddr,
        buf: *mut ::std::os::raw::c_char,
        cbBuf: size_t,
        bWithPort: bool,
    );
}
extern "C" {
    pub fn SteamNetworkingIPAddr_ParseString(
        pAddr: *mut SteamNetworkingIPAddr,
        pszStr: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}SteamNetworkingIPAddr_GetFakeIPType"]
    pub fn SteamNetworkingIPAddr_GetFakeIPType1(
        pAddr: *const SteamNetworkingIPAddr,
    ) -> ESteamNetworkingFakeIPType;
}
extern "C" {
    #[link_name = "\u{1}SteamNetworkingIdentity_ToString"]
    pub fn SteamNetworkingIdentity_ToString1(
        pIdentity: *const SteamNetworkingIdentity,
        buf: *mut ::std::os::raw::c_char,
        cbBuf: size_t,
    );
}
extern "C" {
    #[link_name = "\u{1}SteamNetworkingIdentity_ParseString"]
    pub fn SteamNetworkingIdentity_ParseString1(
        pIdentity: *mut SteamNetworkingIdentity,
        sizeofIdentity: size_t,
        pszStr: *const ::std::os::raw::c_char,
    ) -> bool;
}
pub type uint64_steamid = uint64;
extern "C" {
    pub fn SteamAPI_SteamNetworkingSockets_v009() -> *mut ISteamNetworkingSockets;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateListenSocketIP(
        self_: *mut ISteamNetworkingSockets,
        localAddress: *const SteamNetworkingIPAddr,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamListenSocket;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ConnectByIPAddress(
        self_: *mut ISteamNetworkingSockets,
        address: *const SteamNetworkingIPAddr,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamNetConnection;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2P(
        self_: *mut ISteamNetworkingSockets,
        nLocalVirtualPort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamListenSocket;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ConnectP2P(
        self_: *mut ISteamNetworkingSockets,
        identityRemote: *const SteamNetworkingIdentity,
        nRemoteVirtualPort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamNetConnection;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_AcceptConnection(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CloseConnection(
        self_: *mut ISteamNetworkingSockets,
        hPeer: HSteamNetConnection,
        nReason: ::std::os::raw::c_int,
        pszDebug: *const ::std::os::raw::c_char,
        bEnableLinger: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CloseListenSocket(
        self_: *mut ISteamNetworkingSockets,
        hSocket: HSteamListenSocket,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SetConnectionUserData(
        self_: *mut ISteamNetworkingSockets,
        hPeer: HSteamNetConnection,
        nUserData: int64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetConnectionUserData(
        self_: *mut ISteamNetworkingSockets,
        hPeer: HSteamNetConnection,
    ) -> int64;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SetConnectionName(
        self_: *mut ISteamNetworkingSockets,
        hPeer: HSteamNetConnection,
        pszName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetConnectionName(
        self_: *mut ISteamNetworkingSockets,
        hPeer: HSteamNetConnection,
        pszName: *mut ::std::os::raw::c_char,
        nMaxLen: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SendMessageToConnection(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        pData: *const ::std::os::raw::c_void,
        cbData: uint32,
        nSendFlags: ::std::os::raw::c_int,
        pOutMessageNumber: *mut int64,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SendMessages(
        self_: *mut ISteamNetworkingSockets,
        nMessages: ::std::os::raw::c_int,
        pMessages: *const *mut SteamNetworkingMessage_t,
        pOutMessageNumberOrResult: *mut int64,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_FlushMessagesOnConnection(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnConnection(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        ppOutMessages: *mut *mut SteamNetworkingMessage_t,
        nMaxMessages: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetConnectionInfo(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        pInfo: *mut SteamNetConnectionInfo_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetQuickConnectionStatus(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        pStats: *mut SteamNetConnectionRealTimeStatus_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetDetailedConnectionStatus(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        pszBuf: *mut ::std::os::raw::c_char,
        cbBuf: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetListenSocketAddress(
        self_: *mut ISteamNetworkingSockets,
        hSocket: HSteamListenSocket,
        address: *mut SteamNetworkingIPAddr,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateSocketPair(
        self_: *mut ISteamNetworkingSockets,
        pOutConnection1: *mut HSteamNetConnection,
        pOutConnection2: *mut HSteamNetConnection,
        bUseNetworkLoopback: bool,
        pIdentity1: *const SteamNetworkingIdentity,
        pIdentity2: *const SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetIdentity(
        self_: *mut ISteamNetworkingSockets,
        pIdentity: *mut SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ConfigureConnectionLanes(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        nNumLanes: ::std::os::raw::c_int,
        pLanePriorities: *const ::std::os::raw::c_int,
        pLaneWeights: *const uint16,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_InitAuthentication(
        self_: *mut ISteamNetworkingSockets,
    ) -> ESteamNetworkingAvailability;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetAuthenticationStatus(
        self_: *mut ISteamNetworkingSockets,
        pDetails: *mut SteamNetAuthenticationStatus_t,
    ) -> ESteamNetworkingAvailability;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreatePollGroup(
        self_: *mut ISteamNetworkingSockets,
    ) -> HSteamNetPollGroup;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_DestroyPollGroup(
        self_: *mut ISteamNetworkingSockets,
        hPollGroup: HSteamNetPollGroup,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SetConnectionPollGroup(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        hPollGroup: HSteamNetPollGroup,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnPollGroup(
        self_: *mut ISteamNetworkingSockets,
        hPollGroup: HSteamNetPollGroup,
        ppOutMessages: *mut *mut SteamNetworkingMessage_t,
        nMaxMessages: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ReceivedRelayAuthTicket(
        self_: *mut ISteamNetworkingSockets,
        pvTicket: *const ::std::os::raw::c_void,
        cbTicket: ::std::os::raw::c_int,
        pOutParsedTicket: *mut SteamDatagramRelayAuthTicket,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_FindRelayAuthTicketForServer(
        self_: *mut ISteamNetworkingSockets,
        identityGameServer: *const SteamNetworkingIdentity,
        nRemoteVirtualPort: ::std::os::raw::c_int,
        pOutParsedTicket: *mut SteamDatagramRelayAuthTicket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ConnectToHostedDedicatedServer(
        self_: *mut ISteamNetworkingSockets,
        identityTarget: *const SteamNetworkingIdentity,
        nRemoteVirtualPort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamNetConnection;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPort(
        self_: *mut ISteamNetworkingSockets,
    ) -> uint16;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPOPID(
        self_: *mut ISteamNetworkingSockets,
    ) -> SteamNetworkingPOPID;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerAddress(
        self_: *mut ISteamNetworkingSockets,
        pRouting: *mut SteamDatagramHostedAddress,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateHostedDedicatedServerListenSocket(
        self_: *mut ISteamNetworkingSockets,
        nLocalVirtualPort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamListenSocket;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetGameCoordinatorServerLogin(
        self_: *mut ISteamNetworkingSockets,
        pLoginInfo: *mut SteamDatagramGameCoordinatorServerLogin,
        pcbSignedBlob: *mut ::std::os::raw::c_int,
        pBlob: *mut ::std::os::raw::c_void,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ConnectP2PCustomSignaling(
        self_: *mut ISteamNetworkingSockets,
        pSignaling: *mut ISteamNetworkingConnectionSignaling,
        pPeerIdentity: *const SteamNetworkingIdentity,
        nRemoteVirtualPort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamNetConnection;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ReceivedP2PCustomSignal(
        self_: *mut ISteamNetworkingSockets,
        pMsg: *const ::std::os::raw::c_void,
        cbMsg: ::std::os::raw::c_int,
        pContext: *mut ISteamNetworkingSignalingRecvContext,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetCertificateRequest(
        self_: *mut ISteamNetworkingSockets,
        pcbBlob: *mut ::std::os::raw::c_int,
        pBlob: *mut ::std::os::raw::c_void,
        errMsg: *mut SteamNetworkingErrMsg,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SetCertificate(
        self_: *mut ISteamNetworkingSockets,
        pCertificate: *const ::std::os::raw::c_void,
        cbCertificate: ::std::os::raw::c_int,
        errMsg: *mut SteamNetworkingErrMsg,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_RunCallbacks(self_: *mut ISteamNetworkingSockets);
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingUtils_v003() -> *mut ISteamNetworkingUtils;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_AllocateMessage(
        self_: *mut ISteamNetworkingUtils,
        cbAllocateBuffer: ::std::os::raw::c_int,
    ) -> *mut SteamNetworkingMessage_t;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_InitRelayNetworkAccess(self_: *mut ISteamNetworkingUtils);
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetRelayNetworkStatus(
        self_: *mut ISteamNetworkingUtils,
        pDetails: *mut SteamRelayNetworkStatus_t,
    ) -> ESteamNetworkingAvailability;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetLocalPingLocation(
        self_: *mut ISteamNetworkingUtils,
        result: *mut SteamNetworkPingLocation_t,
    ) -> f32;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_EstimatePingTimeBetweenTwoLocations(
        self_: *mut ISteamNetworkingUtils,
        location1: *const SteamNetworkPingLocation_t,
        location2: *const SteamNetworkPingLocation_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_EstimatePingTimeFromLocalHost(
        self_: *mut ISteamNetworkingUtils,
        remoteLocation: *const SteamNetworkPingLocation_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_ConvertPingLocationToString(
        self_: *mut ISteamNetworkingUtils,
        location: *const SteamNetworkPingLocation_t,
        pszBuf: *mut ::std::os::raw::c_char,
        cchBufSize: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_ParsePingLocationString(
        self_: *mut ISteamNetworkingUtils,
        pszString: *const ::std::os::raw::c_char,
        result: *mut SteamNetworkPingLocation_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_CheckPingDataUpToDate(
        self_: *mut ISteamNetworkingUtils,
        flMaxAgeSeconds: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetPingToDataCenter(
        self_: *mut ISteamNetworkingUtils,
        popID: SteamNetworkingPOPID,
        pViaRelayPoP: *mut SteamNetworkingPOPID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetDirectPingToPOP(
        self_: *mut ISteamNetworkingUtils,
        popID: SteamNetworkingPOPID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetPOPCount(
        self_: *mut ISteamNetworkingUtils,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetPOPList(
        self_: *mut ISteamNetworkingUtils,
        list: *mut SteamNetworkingPOPID,
        nListSz: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetLocalTimestamp(
        self_: *mut ISteamNetworkingUtils,
    ) -> SteamNetworkingMicroseconds;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetDebugOutputFunction(
        self_: *mut ISteamNetworkingUtils,
        eDetailLevel: ESteamNetworkingSocketsDebugOutputType,
        pfnFunc: FSteamNetworkingSocketsDebugOutput,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueInt32(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        val: int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueFloat(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        val: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueString(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        val: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValuePtr(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        val: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueInt32(
        self_: *mut ISteamNetworkingUtils,
        hConn: HSteamNetConnection,
        eValue: ESteamNetworkingConfigValue,
        val: int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueFloat(
        self_: *mut ISteamNetworkingUtils,
        hConn: HSteamNetConnection,
        eValue: ESteamNetworkingConfigValue,
        val: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueString(
        self_: *mut ISteamNetworkingUtils,
        hConn: HSteamNetConnection,
        eValue: ESteamNetworkingConfigValue,
        val: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetConnectionStatusChanged(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetConnectionStatusChanged,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetAuthenticationStatusChanged(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetAuthenticationStatusChanged,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamRelayNetworkStatusChanged(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamRelayNetworkStatusChanged,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetConfigValue(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        eScopeType: ESteamNetworkingConfigScope,
        scopeObj: isize,
        eDataType: ESteamNetworkingConfigDataType,
        pArg: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetConfigValueStruct(
        self_: *mut ISteamNetworkingUtils,
        opt: *const SteamNetworkingConfigValue_t,
        eScopeType: ESteamNetworkingConfigScope,
        scopeObj: isize,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetConfigValue(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        eScopeType: ESteamNetworkingConfigScope,
        scopeObj: isize,
        pOutDataType: *mut ESteamNetworkingConfigDataType,
        pResult: *mut ::std::os::raw::c_void,
        cbResult: *mut size_t,
    ) -> ESteamNetworkingGetConfigValueResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetConfigValueInfo(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        pOutDataType: *mut ESteamNetworkingConfigDataType,
        pOutScope: *mut ESteamNetworkingConfigScope,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_IterateGenericEditableConfigValues(
        self_: *mut ISteamNetworkingUtils,
        eCurrent: ESteamNetworkingConfigValue,
        bEnumerateDevVars: bool,
    ) -> ESteamNetworkingConfigValue;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_Clear(self_: *mut SteamNetworkingIPAddr);
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_IsIPv6AllZeros(self_: *mut SteamNetworkingIPAddr)
        -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_SetIPv6(
        self_: *mut SteamNetworkingIPAddr,
        ipv6: *const uint8,
        nPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_SetIPv4(
        self_: *mut SteamNetworkingIPAddr,
        nIP: uint32,
        nPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_IsIPv4(self_: *mut SteamNetworkingIPAddr) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_GetIPv4(self_: *mut SteamNetworkingIPAddr) -> uint32;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_SetIPv6LocalHost(
        self_: *mut SteamNetworkingIPAddr,
        nPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_IsLocalHost(self_: *mut SteamNetworkingIPAddr) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_IsEqualTo(
        self_: *mut SteamNetworkingIPAddr,
        x: *const SteamNetworkingIPAddr,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_ToString(
        self_: *const SteamNetworkingIPAddr,
        buf: *mut ::std::os::raw::c_char,
        cbBuf: size_t,
        bWithPort: bool,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_ParseString(
        self_: *mut SteamNetworkingIPAddr,
        pszStr: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_Clear(self_: *mut SteamNetworkingIdentity);
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_IsInvalid(self_: *mut SteamNetworkingIdentity) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetSteamID(
        self_: *mut SteamNetworkingIdentity,
        steamID: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetSteamID(
        self_: *mut SteamNetworkingIdentity,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetSteamID64(
        self_: *mut SteamNetworkingIdentity,
        steamID: uint64,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetSteamID64(
        self_: *mut SteamNetworkingIdentity,
    ) -> uint64;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetIPAddr(
        self_: *mut SteamNetworkingIdentity,
        addr: *const SteamNetworkingIPAddr,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetIPAddr(
        self_: *mut SteamNetworkingIdentity,
    ) -> *const SteamNetworkingIPAddr;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetLocalHost(self_: *mut SteamNetworkingIdentity);
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_IsLocalHost(
        self_: *mut SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetGenericString(
        self_: *mut SteamNetworkingIdentity,
        pszString: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetGenericString(
        self_: *mut SteamNetworkingIdentity,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetGenericBytes(
        self_: *mut SteamNetworkingIdentity,
        data: *const ::std::os::raw::c_void,
        cbLen: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetGenericBytes(
        self_: *mut SteamNetworkingIdentity,
        cbLen: *mut ::std::os::raw::c_int,
    ) -> *const uint8;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_IsEqualTo(
        self_: *mut SteamNetworkingIdentity,
        x: *const SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_ToString(
        self_: *const SteamNetworkingIdentity,
        buf: *mut ::std::os::raw::c_char,
        cbBuf: size_t,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_ParseString(
        self_: *mut SteamNetworkingIdentity,
        sizeofIdentity: size_t,
        pszStr: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingMessage_t_Release(self_: *mut SteamNetworkingMessage_t);
}
pub type FSteamNetworkingSocketsCustomSignaling_SendSignal = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        hConn: HSteamNetConnection,
        info: *const SteamNetConnectionInfo_t,
        pMsg: *const ::std::os::raw::c_void,
        cbMsg: ::std::os::raw::c_int,
    ) -> bool,
>;
pub type FSteamNetworkingSocketsCustomSignaling_Release =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Create an ISteamNetworkingConnectionSignaling object from plain C primitives."]
    pub fn SteamAPI_ISteamNetworkingSockets_CreateCustomSignaling(
        ctx: *mut ::std::os::raw::c_void,
        fnSendSignal: FSteamNetworkingSocketsCustomSignaling_SendSignal,
        fnRelease: FSteamNetworkingSocketsCustomSignaling_Release,
    ) -> *mut ISteamNetworkingConnectionSignaling;
}
pub type FSteamNetworkingCustomSignalingRecvContext_OnConnectRequest = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        hConn: HSteamNetConnection,
        identityPeer: *const SteamNetworkingIdentity,
        nLocalVirtualPort: ::std::os::raw::c_int,
    ) -> *mut ISteamNetworkingConnectionSignaling,
>;
pub type FSteamNetworkingCustomSignalingRecvContext_SendRejectionSignal = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        identityPeer: *const SteamNetworkingIdentity,
        pMsg: *const ::std::os::raw::c_void,
        cbMsg: ::std::os::raw::c_int,
    ),
>;
extern "C" {
    #[doc = " Same as SteamAPI_ISteamNetworkingSockets_ReceivedP2PCustomSignal, but using plain C primitives."]
    pub fn SteamAPI_ISteamNetworkingSockets_ReceivedP2PCustomSignal2(
        self_: *mut ISteamNetworkingSockets,
        pMsg: *const ::std::os::raw::c_void,
        cbMsg: ::std::os::raw::c_int,
        ctx: *mut ::std::os::raw::c_void,
        fnOnConnectRequest: FSteamNetworkingCustomSignalingRecvContext_OnConnectRequest,
        fnSendRejectionSignal: FSteamNetworkingCustomSignalingRecvContext_SendRejectionSignal,
    ) -> bool;
}
extern "C" {
    pub fn GameNetworkingSockets_Init(
        pIdentity: *const SteamNetworkingIdentity,
        errMsg: *mut SteamNetworkingErrMsg,
    ) -> bool;
}
extern "C" {
    pub fn GameNetworkingSockets_Kill();
}
extern "C" {
    #[doc = " Custom memory allocation methods.  If you call this, you MUST call it exactly once,"]
    #[doc = " before calling any other API function.  *Most* allocations will pass through these,"]
    #[doc = " especially all allocations that are per-connection.  A few allocations"]
    #[doc = " might still go to the default CRT malloc and operator new."]
    #[doc = " To use this, you must compile the library with STEAMNETWORKINGSOCKETS_ENABLE_MEM_OVERRIDE"]
    pub fn SteamNetworkingSockets_SetCustomMemoryAllocator(
        pfn_malloc: ::std::option::Option<
            unsafe extern "C" fn(s: size_t) -> *mut ::std::os::raw::c_void,
        >,
        pfn_free: ::std::option::Option<unsafe extern "C" fn(p: *mut ::std::os::raw::c_void)>,
        pfn_realloc: ::std::option::Option<
            unsafe extern "C" fn(
                p: *mut ::std::os::raw::c_void,
                s: size_t,
            ) -> *mut ::std::os::raw::c_void,
        >,
    );
}
extern "C" {
    pub fn SteamNetworkingSockets_SetLockWaitWarningThreshold(
        usecThreshold: SteamNetworkingMicroseconds,
    );
}
extern "C" {
    pub fn SteamNetworkingSockets_SetLockAcquiredCallback(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                tags: *const ::std::os::raw::c_char,
                usecWaited: SteamNetworkingMicroseconds,
            ),
        >,
    );
}
extern "C" {
    pub fn SteamNetworkingSockets_SetLockHeldCallback(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                tags: *const ::std::os::raw::c_char,
                usecWaited: SteamNetworkingMicroseconds,
            ),
        >,
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __locale_data {
    pub _address: u8,
}
